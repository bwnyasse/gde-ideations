# Source Code Documentation
\n## Project Structure\n
\n### firebase_options.dart\n
```dart
// File generated by FlutterFire CLI.
// ignore_for_file: type=lint
import 'package:firebase_core/firebase_core.dart' show FirebaseOptions;
import 'package:flutter/foundation.dart'
    show defaultTargetPlatform, kIsWeb, TargetPlatform;

/// Default [FirebaseOptions] for use with your Firebase apps.
///
/// Example:
/// ```dart
/// import 'firebase_options.dart';
/// // ...
/// await Firebase.initializeApp(
///   options: DefaultFirebaseOptions.currentPlatform,
/// );
/// ```
class DefaultFirebaseOptions {
  static FirebaseOptions get currentPlatform {
    if (kIsWeb) {
      throw UnsupportedError(
        'DefaultFirebaseOptions have not been configured for web - '
        'you can reconfigure this by running the FlutterFire CLI again.',
      );
    }
    switch (defaultTargetPlatform) {
      case TargetPlatform.android:
        return android;
      case TargetPlatform.iOS:
        throw UnsupportedError(
          'DefaultFirebaseOptions have not been configured for ios - '
          'you can reconfigure this by running the FlutterFire CLI again.',
        );
      case TargetPlatform.macOS:
        throw UnsupportedError(
          'DefaultFirebaseOptions have not been configured for macos - '
          'you can reconfigure this by running the FlutterFire CLI again.',
        );
      case TargetPlatform.windows:
        throw UnsupportedError(
          'DefaultFirebaseOptions have not been configured for windows - '
          'you can reconfigure this by running the FlutterFire CLI again.',
        );
      case TargetPlatform.linux:
        throw UnsupportedError(
          'DefaultFirebaseOptions have not been configured for linux - '
          'you can reconfigure this by running the FlutterFire CLI again.',
        );
      default:
        throw UnsupportedError(
          'DefaultFirebaseOptions are not supported for this platform.',
        );
    }
  }

  static const FirebaseOptions android = FirebaseOptions(
    apiKey: 'AIzaSyCHk-o2MoCxroAM5rjhVsGI77RZi2drqfM',
    appId: '1:553140087820:android:a8c79c54f1da5c6ed51229',
    messagingSenderId: '553140087820',
    projectId: 'learning-box-369917',
    storageBucket: 'learning-box-369917.firebasestorage.app',
  );

}```\n
\n### main.dart\n
```dart
import 'package:flutter/material.dart';
import 'package:oloodi_scrabble_moderator_app/src/screens/game_sessions_list_screen.dart';
import 'package:provider/provider.dart';
import 'src/providers/game_session_provider.dart';
import 'src/themes/app_theme.dart';
import 'package:firebase_core/firebase_core.dart';
import 'firebase_options.dart';

void main() async {
  WidgetsFlutterBinding.ensureInitialized();
  await Firebase.initializeApp(
    options: DefaultFirebaseOptions.currentPlatform,
  );
  runApp(const ModeratorApp());
}

class ModeratorApp extends StatelessWidget {
  const ModeratorApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MultiProvider(
      providers: [
        ChangeNotifierProvider(create: (_) => GameSessionProvider()),
      ],
      child: MaterialApp(
        title: 'Scrabble Moderator',
        theme: AppTheme.theme,
        home: const GameSessionsListScreen(),
      ),
    );
  }
}
```\n
\n### src/config/env_config.dart\n
```dart
// lib/config/env_config.dart
import 'package:flutter_dotenv/flutter_dotenv.dart';

class EnvConfig {
  static String get geminiApiKey {
    try {
      return dotenv.get('GEMINI_API_KEY', fallback: '');
    } catch (e) {
      return '';
    }
  }

  static String get elevenLabsApiKey {
    try {
      return dotenv.get('ELEVEN_LABS_API_KEY', fallback: '');
    } catch (e) {
      return '';
    }
  }

  static String get elevenLabsVoiceId {
    try {
      return dotenv.get('ELEVEN_LABS_VOICE_ID', fallback: '');
    } catch (e) {
      return '';
    }
  }

  static bool get isConfigured {
    return geminiApiKey.isNotEmpty && 
           elevenLabsApiKey.isNotEmpty && 
           elevenLabsVoiceId.isNotEmpty;
  }

  static List<String> getMissingConfigurations() {
    final missing = <String>[];
    
    if (geminiApiKey.isEmpty) {
      missing.add('Gemini API Key');
    }
    if (elevenLabsApiKey.isEmpty) {
      missing.add('ElevenLabs API Key');
    }
    if (elevenLabsVoiceId.isEmpty) {
      missing.add('ElevenLabs Voice ID');
    }
    
    return missing;
  }
}```\n
\n### src/providers/game_session_provider.dart\n
```dart
// lib/src/providers/game_session_provider.dart
import 'package:flutter/foundation.dart';
import 'package:oloodi_scrabble_moderator_app/src/models/game_session.dart';
import 'package:oloodi_scrabble_moderator_app/src/services/firebase_service.dart';
import 'package:oloodi_scrabble_moderator_app/src/services/qr_service.dart';

class GameSessionProvider with ChangeNotifier {
  final FirebaseService _firebaseService = FirebaseService();
  final QRService _qrService = QRService();

  GameSession? _currentSession;
  bool _isLoading = false;
  String? _error;

  // Getters
  GameSession? get currentSession => _currentSession;
  bool get isLoading => _isLoading;
  String? get error => _error;
  bool get hasActiveSession =>
      _currentSession != null && _currentSession!.isActive;

  // Create new game session
  Future<void> createGameSession(String player1Name, String player2Name) async {
    try {
      _setLoading(true);
      _clearError();

      // Create session in Firebase
      final session = await _firebaseService.createGameSession(
        player1Name: player1Name,
        player2Name: player2Name,
      );

      // Generate QR code data string
      final qrCodeData = _qrService.generateQRCodeData(session.id);

      // Update session with QR code data
      _currentSession = await _firebaseService.updateSessionQRCode(
        session.id,
        qrCodeData,
      );

      notifyListeners();
    } catch (e) {
      _setError('Failed to create game session: $e');
    } finally {
      _setLoading(false);
    }
  }

  // End current session
  Future<void> endCurrentSession() async {
    if (_currentSession == null) return;

    try {
      _setLoading(true);
      _clearError();

      await _firebaseService.updateSessionStatus(
        _currentSession!.id,
        false,
      );

      _currentSession = null;
      notifyListeners();
    } catch (e) {
      _setError('Failed to end session: $e');
    } finally {
      _setLoading(false);
    }
  }

  // Add move to current session
  Future<void> addMove({
    required String word,
    required int score,
    required String playerId,
    required List<Map<String, dynamic>> tiles,
  }) async {
    if (_currentSession == null) {
      _setError('No active session');
      return;
    }

    try {
      _setLoading(true);
      _clearError();

      await _firebaseService.addMoveToSession(
        sessionId: _currentSession!.id,
        word: word,
        score: score,
        playerId: playerId,
        tiles: tiles,
      );

      notifyListeners();
    } catch (e) {
      _setError('Failed to add move: $e');
    } finally {
      _setLoading(false);
    }
  }

  // Load existing session
  Future<void> loadSession(String sessionId) async {
    try {
      _setLoading(true);
      _clearError();

      _currentSession = await _firebaseService.getSession(sessionId);
      notifyListeners();
    } catch (e) {
      _setError('Failed to load session: $e');
    } finally {
      _setLoading(false);
    }
  }

  // Helper methods
  void _setLoading(bool loading) {
    _isLoading = loading;
    notifyListeners();
  }

  void _setError(String error) {
    _error = error;
    notifyListeners();
  }

  void _clearError() {
    _error = null;
  }

  // Get stream of all sessions
  Stream<List<GameSession>> getSessions() {
    return _firebaseService.getGameSessions().map((snapshot) => snapshot.docs
        .map((doc) => GameSession.fromMap(doc.data() as Map<String, dynamic>))
        .toList());
  }

  // Delete multiple sessions
  Future<void> deleteSessions(List<String> sessionIds) async {
    try {
      _setLoading(true);
      _clearError();

      for (final sessionId in sessionIds) {
        await _firebaseService.deleteSession(sessionId);
      }
    } catch (e) {
      _setError('Failed to delete sessions: $e');
      rethrow;
    } finally {
      _setLoading(false);
    }
  }

  // Get session statistics
  Future<Map<String, dynamic>> getSessionStats(String sessionId) async {
    try {
      final moves = await _firebaseService.getSessionMoves(sessionId).first;
      final remainingLetters =
          await _firebaseService.getRemainingLetters(sessionId);

      return {
        'totalMoves': moves.length,
        'remainingLetters': remainingLetters,
        'player1Score': moves
            .where((m) => m['playerId'] == 'p1')
            .fold(0, (sum, m) => sum + (m['score'] as int)),
        'player2Score': moves
            .where((m) => m['playerId'] == 'p2')
            .fold(0, (sum, m) => sum + (m['score'] as int)),
      };
    } catch (e) {
      _setError('Failed to get session stats: $e');
      rethrow;
    }
  }
}
```\n
\n### src/models/game_session.dart\n
```dart
// lib/src/models/game_session.dart
import 'package:cloud_firestore/cloud_firestore.dart';

class GameSession {
  final String id;
  final String player1Name;
  final String player2Name;
  final DateTime startTime;
  final String? qrCode;
  final String currentPlayerId;  // Added this field
  bool isActive;

  GameSession({
    required this.id,
    required this.player1Name,
    required this.player2Name,
    required this.startTime,
    this.qrCode,
    this.currentPlayerId = 'p1',  // Default to player 1
    this.isActive = true,
  });

  // Optional: Add a factory constructor to create from Firebase data
  factory GameSession.fromMap(Map<String, dynamic> data) {
    return GameSession(
      id: data['id'],
      player1Name: data['player1Name'],
      player2Name: data['player2Name'],
      startTime: (data['startTime'] as Timestamp).toDate(),
      qrCode: data['qrCode'],
      currentPlayerId: data['currentPlayerId'] ?? 'p1',
      isActive: data['isActive'] ?? true,
    );
  }

  // Optional: Add a method to convert to Map for Firebase
  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'player1Name': player1Name,
      'player2Name': player2Name,
      'startTime': startTime,
      'qrCode': qrCode,
      'currentPlayerId': currentPlayerId,
      'isActive': isActive,
    };
  }

  // Helper method to get the next player's ID
  String getNextPlayerId() {
    return currentPlayerId == 'p1' ? 'p2' : 'p1';
  }
}```\n
\n### src/screens/game_monitoring_screen.dart\n
```dart
// lib/src/screens/game_monitoring_screen.dart
import 'package:flutter/material.dart';
import 'package:oloodi_scrabble_moderator_app/src/services/qr_service.dart';
import 'package:provider/provider.dart';
import '../providers/game_session_provider.dart';
import '../widgets/move_history_widget.dart';
import '../widgets/player_info_widget.dart';
import 'move_capture_screen.dart';

class GameMonitoringScreen extends StatelessWidget {
  final String sessionId;

  const GameMonitoringScreen({
    super.key,
    required this.sessionId,
  });

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Game Monitoring'),
        actions: [
          IconButton(
            icon: const Icon(Icons.qr_code),
            onPressed: () => _showQRCode(context),
          ),
          IconButton(
            icon: const Icon(Icons.stop),
            onPressed: () => _endGame(context),
          ),
        ],
      ),
      body: FutureBuilder<void>(
        future: context.read<GameSessionProvider>().loadSession(sessionId),
        builder: (context, snapshot) {
          if (snapshot.hasError) {
            return Center(child: Text('Error: ${snapshot.error}'));
          }

          return Consumer<GameSessionProvider>(
            builder: (context, provider, child) {
              if (provider.isLoading) {
                return const Center(child: CircularProgressIndicator());
              }

              if (provider.error != null) {
                return Center(child: Text(provider.error!));
              }

              if (provider.currentSession == null) {
                return const Center(child: Text('Session not found'));
              }

              return Column(
                children: [
                  // Player information
                  PlayerInfoWidget(
                    player1Name: provider.currentSession!.player1Name,
                    player2Name: provider.currentSession!.player2Name,
                  ),
                  
                  // Move history
                  const Expanded(
                    child: MoveHistoryWidget(),
                  ),
                ],
              );
            },
          );
        },
      ),
      floatingActionButton: FloatingActionButton.extended(
        onPressed: () => _captureMove(context),
        icon: const Icon(Icons.camera_alt),
        label: const Text('Capture Move'),
      ),
    );
  }

  void _showQRCode(BuildContext context) {
    Navigator.push(
      context,
      MaterialPageRoute(
        builder: (_) => QRDisplayScreen(sessionId: sessionId),
      ),
    );
  }

  void _captureMove(BuildContext context) {
    Navigator.push(
      context,
      MaterialPageRoute(
        builder: (_) => const MoveCaptureScreen(),
      ),
    );
  }

  Future<void> _endGame(BuildContext context) async {
    final confirmed = await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('End Game'),
        content: const Text('Are you sure you want to end this game?'),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context, false),
            child: const Text('Cancel'),
          ),
          TextButton(
            onPressed: () => Navigator.pop(context, true),
            child: const Text('End Game'),
          ),
        ],
      ),
    );

    if (confirmed != true || !context.mounted) return;

    try {
      await context.read<GameSessionProvider>().endCurrentSession();
      if (!context.mounted) return;
      Navigator.of(context).popUntil((route) => route.isFirst);
    } catch (e) {
      if (!context.mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Failed to end game: $e')),
      );
    }
  }
}```\n
\n### src/screens/game_sessions_list_screen.dart\n
```dart
// lib/src/screens/game_sessions_list_screen.dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:intl/intl.dart';
import '../providers/game_session_provider.dart';
import '../models/game_session.dart';
import 'game_setup_screen.dart';
import 'game_monitoring_screen.dart';

class GameSessionsListScreen extends StatefulWidget {
  const GameSessionsListScreen({super.key});

  @override
  State<GameSessionsListScreen> createState() => _GameSessionsListScreenState();
}

class _GameSessionsListScreenState extends State<GameSessionsListScreen> {
  final Set<String> _selectedSessions = {};

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Game Sessions'),
        actions: [
          if (_selectedSessions.isNotEmpty)
            IconButton(
              icon: const Icon(Icons.delete),
              onPressed: _deleteSelectedSessions,
            ),
        ],
      ),
      body: StreamBuilder<List<GameSession>>(
        stream: context.read<GameSessionProvider>().getSessions(),
        builder: (context, snapshot) {
          if (snapshot.hasError) {
            return Center(
              child: Text('Error: ${snapshot.error}'),
            );
          }

          if (snapshot.connectionState == ConnectionState.waiting) {
            return const Center(
              child: CircularProgressIndicator(),
            );
          }

          final sessions = snapshot.data ?? [];
          if (sessions.isEmpty) {
            return Center(
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  const Icon(Icons.sports_esports_outlined, size: 64, color: Colors.grey),
                  const SizedBox(height: 16),
                  const Text(
                    'No game sessions yet',
                    style: TextStyle(fontSize: 18, color: Colors.grey),
                  ),
                  const SizedBox(height: 8),
                  const Text(
                    'Create a new game to get started',
                    style: TextStyle(color: Colors.grey),
                  ),
                ],
              ),
            );
          }

          return ListView.builder(
            itemCount: sessions.length,
            itemBuilder: (context, index) {
              final session = sessions[index];
              return _buildSessionCard(session);
            },
          );
        },
      ),
      floatingActionButton: FloatingActionButton.extended(
        onPressed: () => _navigateToGameSetup(context),
        icon: const Icon(Icons.add),
        label: const Text('Start Game'),
      ),
    );
  }

  Widget _buildSessionCard(GameSession session) {
    final dateFormat = DateFormat('MMM d, y â€“ h:mm a');
    final isSelected = _selectedSessions.contains(session.id);

    return Card(
      margin: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
      child: InkWell(
        onTap: () => _navigateToSession(session),
        onLongPress: () => _toggleSessionSelection(session.id),
        child: Container(
          padding: const EdgeInsets.all(16),
          color: isSelected ? Colors.blue.withOpacity(0.1) : null,
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Row(
                children: [
                  Expanded(
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Row(
                          children: [
                            Text(
                              '${session.player1Name} vs ${session.player2Name}',
                              style: const TextStyle(
                                fontSize: 16,
                                fontWeight: FontWeight.bold,
                              ),
                            ),
                            if (session.isActive)
                              Container(
                                margin: const EdgeInsets.only(left: 8),
                                padding: const EdgeInsets.symmetric(
                                  horizontal: 8,
                                  vertical: 2,
                                ),
                                decoration: BoxDecoration(
                                  color: Colors.green,
                                  borderRadius: BorderRadius.circular(12),
                                ),
                                child: const Text(
                                  'Active',
                                  style: TextStyle(
                                    color: Colors.white,
                                    fontSize: 12,
                                  ),
                                ),
                              ),
                          ],
                        ),
                        const SizedBox(height: 4),
                        Text(
                          dateFormat.format(session.startTime),
                          style: TextStyle(
                            color: Colors.grey[600],
                            fontSize: 12,
                          ),
                        ),
                      ],
                    ),
                  ),
                  if (isSelected)
                    const Icon(Icons.check_circle, color: Colors.blue)
                  else
                    const Icon(Icons.chevron_right, color: Colors.grey),
                ],
              ),
              if (session.isActive) ...[
                const SizedBox(height: 16),
                _buildGameStats(session),
              ],
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildGameStats(GameSession session) {
    return FutureBuilder<Map<String, dynamic>>(
      future: context.read<GameSessionProvider>().getSessionStats(session.id),
      builder: (context, snapshot) {
        if (!snapshot.hasData) {
          return const SizedBox();
        }

        final stats = snapshot.data!;
        return Row(
          mainAxisAlignment: MainAxisAlignment.spaceAround,
          children: [
            _buildStatItem('Moves', stats['totalMoves']?.toString() ?? '0'),
            _buildStatItem('Letters Remaining', stats['remainingLetters']?.toString() ?? '-'),
            _buildStatItem('Duration', _formatDuration(session.startTime)),
          ],
        );
      },
    );
  }

  Widget _buildStatItem(String label, String value) {
    return Column(
      children: [
        Text(
          value,
          style: const TextStyle(
            fontSize: 16,
            fontWeight: FontWeight.bold,
          ),
        ),
        Text(
          label,
          style: TextStyle(
            fontSize: 12,
            color: Colors.grey[600],
          ),
        ),
      ],
    );
  }

  String _formatDuration(DateTime startTime) {
    final duration = DateTime.now().difference(startTime);
    final hours = duration.inHours;
    final minutes = duration.inMinutes % 60;
    return '${hours}h ${minutes}m';
  }

  void _toggleSessionSelection(String sessionId) {
    setState(() {
      if (_selectedSessions.contains(sessionId)) {
        _selectedSessions.remove(sessionId);
      } else {
        _selectedSessions.add(sessionId);
      }
    });
  }

  Future<void> _deleteSelectedSessions() async {
    final confirmed = await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Delete Sessions'),
        content: Text(
          'Are you sure you want to delete ${_selectedSessions.length} selected session(s)?',
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context, false),
            child: const Text('Cancel'),
          ),
          TextButton(
            onPressed: () => Navigator.pop(context, true),
            child: const Text('Delete'),
          ),
        ],
      ),
    );

    if (confirmed == true && mounted) {
      try {
        await context.read<GameSessionProvider>().deleteSessions(_selectedSessions.toList());
        setState(() {
          _selectedSessions.clear();
        });
      } catch (e) {
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(content: Text('Error deleting sessions: $e')),
          );
        }
      }
    }
  }

  void _navigateToSession(GameSession session) {
    Navigator.push(
      context,
      MaterialPageRoute(
        builder: (context) => GameMonitoringScreen(sessionId: session.id),
      ),
    );
  }

  void _navigateToGameSetup(BuildContext context) {
    Navigator.push(
      context,
      MaterialPageRoute(
        builder: (context) => const GameSetupScreen(),
      ),
    );
  }
}```\n
\n### src/screens/qr_display_screen.dart\n
```dart
```\n
\n### src/screens/move_capture_screen.dart\n
```dart
// lib/src/screens/move_capture_screen.dart
import 'package:camera/camera.dart';
import 'package:flutter/material.dart';
import 'package:permission_handler/permission_handler.dart';
import 'package:provider/provider.dart';
import '../providers/game_session_provider.dart';
import '../services/gemini_service.dart';

class MoveCaptureScreen extends StatefulWidget {
  const MoveCaptureScreen({super.key});

  @override
  State<MoveCaptureScreen> createState() => _MoveCaptureScreenState();
}

class _MoveCaptureScreenState extends State<MoveCaptureScreen>
    with WidgetsBindingObserver {
  CameraController? _controller;
  bool _isCameraInitialized = false;
  String? _error;
  bool _processing = false;
  final GeminiService _geminiService = GeminiService();

  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addObserver(this);
    _requestCameraPermission();
  }

  @override
  void dispose() {
    WidgetsBinding.instance.removeObserver(this);
    _controller?.dispose();
    super.dispose();
  }

  @override
  void didChangeAppLifecycleState(AppLifecycleState state) {
    final CameraController? cameraController = _controller;

    if (cameraController == null || !cameraController.value.isInitialized) {
      return;
    }

    if (state == AppLifecycleState.inactive) {
      cameraController.dispose();
    } else if (state == AppLifecycleState.resumed) {
      _initializeCamera();
    }
  }

  Future<void> _requestCameraPermission() async {
    var status = await Permission.camera.status;
    if (status.isGranted) {
      _initializeCamera();
      return;
    }

    status = await Permission.camera.request();
    if (status.isGranted) {
      _initializeCamera();
    } else if (status.isPermanentlyDenied) {
      if (mounted) {
        setState(() {
          _error =
              'Camera permission was permanently denied. Please enable it in app settings.';
        });
      }
    } else {
      if (mounted) {
        setState(() {
          _error =
              'Camera permission is required to capture moves. Please grant the permission.';
        });
      }
    }
  }

  Future<void> _initializeCamera() async {
    try {
      final cameras = await availableCameras();
      if (cameras.isEmpty) {
        setState(() => _error = 'No cameras available');
        return;
      }

      final controller = CameraController(
        cameras.first,
        ResolutionPreset.max,
        enableAudio: false,
      );

      await controller.initialize();

      if (mounted) {
        setState(() {
          _controller = controller;
          _isCameraInitialized = true;
          _error = null;
        });
      }
    } catch (e) {
      setState(() => _error = 'Error initializing camera: $e');
    }
  }

  Future<void> _captureAndAnalyze() async {
    if (_processing ||
        _controller == null ||
        !_controller!.value.isInitialized) {
      return;
    }

    setState(() => _processing = true);

    try {
      // Show processing indicator
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Processing image...')),
      );

      // Capture image
      final image = await _controller!.takePicture();

      // Get current player ID
      final gameState = context.read<GameSessionProvider>();
      final currentPlayerId = gameState.currentSession?.currentPlayerId;

      if (currentPlayerId == null) {
        throw Exception('No active game session');
      }
      
      final sessionId = gameState.currentSession!.id;
      // Analyze with Gemini
      final analysis = await _geminiService.analyzeBoardImage(
        sessionId,
        image.path,
      );

      if (!mounted) return;

      // Close the processing snackbar
      ScaffoldMessenger.of(context).hideCurrentSnackBar();

      if (analysis['status'] == 'success') {
        // Show confirmation dialog
        final confirmed = await _showMoveConfirmation(analysis['data']);

        if (confirmed && mounted) {
          // Add move to session
          await context.read<GameSessionProvider>().addMove(
                word: analysis['data']['word'],
                score: analysis['data']['score'],
                playerId: currentPlayerId,
                tiles: analysis['data']['tiles'],
              );

          if (mounted) {
            Navigator.pop(context);
          }
        }
      } else {
        throw Exception(analysis['message']);
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error: $e'),
            backgroundColor: Colors.red,
          ),
        );
      }
    } finally {
      if (mounted) {
        setState(() => _processing = false);
      }
    }
  }

  Future<bool> _showMoveConfirmation(Map<String, dynamic> moveData) async {
    return await showDialog<bool>(
          context: context,
          barrierDismissible: false,
          builder: (context) => AlertDialog(
            title: const Text('Confirm Move'),
            content: Column(
              mainAxisSize: MainAxisSize.min,
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text('Word: ${moveData['word']}'),
                const SizedBox(height: 8),
                Text('Score: ${moveData['score']} points'),
                if (moveData['tiles'] != null) ...[
                  const SizedBox(height: 16),
                  const Text('Tiles placed:'),
                  const SizedBox(height: 8),
                  Wrap(
                    spacing: 8,
                    children: [
                      for (var tile in moveData['tiles'])
                        Chip(
                          label: Text('${tile['letter']} (${tile['points']})'),
                        ),
                    ],
                  ),
                ],
              ],
            ),
            actions: [
              TextButton(
                onPressed: () => Navigator.pop(context, false),
                child: const Text('Retake'),
              ),
              TextButton(
                onPressed: () => Navigator.pop(context, true),
                child: const Text('Confirm'),
              ),
            ],
          ),
        ) ??
        false;
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Capture Move'),
      ),
      body: _buildBody(),
    );
  }

  Widget _buildBody() {
    if (_error != null) {
      return Center(
        child: Padding(
          padding: const EdgeInsets.all(16.0),
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              Text(
                _error!,
                textAlign: TextAlign.center,
                style: const TextStyle(color: Colors.red),
              ),
              const SizedBox(height: 16),
              ElevatedButton(
                onPressed: _requestCameraPermission,
                child: const Text('Grant Camera Permission'),
              ),
              const SizedBox(height: 8),
              TextButton(
                onPressed: () => openAppSettings(),
                child: const Text('Open App Settings'),
              ),
            ],
          ),
        ),
      );
    }

    if (!_isCameraInitialized || _controller == null) {
      return const Center(child: CircularProgressIndicator());
    }

    return Stack(
      fit: StackFit.expand,
      children: [
        // Camera Preview
        CameraPreview(_controller!),

        // Capture Guide Overlay
        CustomPaint(
          painter: BoardOverlayPainter(),
        ),

        // Processing Indicator
        if (_processing)
          Container(
            color: Colors.black54,
            child: const Center(
              child: CircularProgressIndicator(color: Colors.white),
            ),
          ),

        // Capture Button
        Positioned(
          bottom: 32,
          left: 0,
          right: 0,
          child: Center(
            child: FloatingActionButton(
              onPressed: _processing ? null : _captureAndAnalyze,
              child: _processing
                  ? const SizedBox(
                      width: 24,
                      height: 24,
                      child: CircularProgressIndicator(
                        color: Colors.white,
                        strokeWidth: 2,
                      ),
                    )
                  : const Icon(Icons.camera_alt),
            ),
          ),
        ),

        // Instructions
        Positioned(
          bottom: 0,
          left: 0,
          right: 0,
          child: Container(
            color: Colors.black54,
            padding: const EdgeInsets.all(16),
            child: const Text(
              'Position the board within the guide and ensure good lighting',
              style: TextStyle(color: Colors.white),
              textAlign: TextAlign.center,
            ),
          ),
        ),
      ],
    );
  }
}

class BoardOverlayPainter extends CustomPainter {
  @override
  void paint(Canvas canvas, Size size) {
    final paint = Paint()
      ..color = Colors.white.withOpacity(0.3)
      ..style = PaintingStyle.stroke
      ..strokeWidth = 2.0;

    // Calculate square size to maintain aspect ratio
    final squareSize =
        size.width < size.height ? size.width * 0.8 : size.height * 0.8;
    final left = (size.width - squareSize) / 2;
    final top = (size.height - squareSize) / 2;
    final rect = Rect.fromLTWH(left, top, squareSize, squareSize);

    // Draw the main rectangle
    canvas.drawRect(rect, paint);

    // Draw corner markers
    final cornerLength = squareSize * 0.1;
    final corners = [
      [
        rect.topLeft,
        Offset(rect.left + cornerLength, rect.top),
        Offset(rect.left, rect.top + cornerLength)
      ],
      [
        rect.topRight,
        Offset(rect.right - cornerLength, rect.top),
        Offset(rect.right, rect.top + cornerLength)
      ],
      [
        rect.bottomLeft,
        Offset(rect.left + cornerLength, rect.bottom),
        Offset(rect.left, rect.bottom - cornerLength)
      ],
      [
        rect.bottomRight,
        Offset(rect.right - cornerLength, rect.bottom),
        Offset(rect.right, rect.bottom - cornerLength)
      ],
    ];

    for (final corner in corners) {
      canvas.drawLine(corner[0], corner[1], paint);
      canvas.drawLine(corner[0], corner[2], paint);
    }
  }

  @override
  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;
}
```\n
\n### src/screens/game_setup_screen.dart\n
```dart
// lib/src/screens/game_setup_screen.dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../providers/game_session_provider.dart';
import 'game_monitoring_screen.dart';

class GameSetupScreen extends StatefulWidget {
  const GameSetupScreen({super.key});

  @override
  State<GameSetupScreen> createState() => _GameSetupScreenState();
}

class _GameSetupScreenState extends State<GameSetupScreen> {
  final _formKey = GlobalKey<FormState>();
  final _player1Controller = TextEditingController();
  final _player2Controller = TextEditingController();
  bool _isProcessing = false;

  @override
  void dispose() {
    _player1Controller.dispose();
    _player2Controller.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('New Game Setup'),
      ),
      body: Padding(
        padding: const EdgeInsets.all(16),
        child: Form(
          key: _formKey,
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.stretch,
            children: [
              TextFormField(
                controller: _player1Controller,
                decoration: const InputDecoration(
                  labelText: 'Player 1 Name',
                  prefixIcon: Icon(Icons.person),
                ),
                validator: (value) {
                  if (value == null || value.trim().isEmpty) {
                    return 'Please enter player 1 name';
                  }
                  return null;
                },
              ),
              const SizedBox(height: 16),
              TextFormField(
                controller: _player2Controller,
                decoration: const InputDecoration(
                  labelText: 'Player 2 Name',
                  prefixIcon: Icon(Icons.person),
                ),
                validator: (value) {
                  if (value == null || value.trim().isEmpty) {
                    return 'Please enter player 2 name';
                  }
                  return null;
                },
              ),
              const SizedBox(height: 32),
              ElevatedButton(
                onPressed: _isProcessing ? null : _startGame,
                style: ElevatedButton.styleFrom(
                  padding: const EdgeInsets.symmetric(vertical: 16),
                ),
                child: _isProcessing
                    ? const CircularProgressIndicator()
                    : const Text('Start Game'),
              ),
              if (context.select((GameSessionProvider p) => p.error) != null)
                Padding(
                  padding: const EdgeInsets.only(top: 16),
                  child: Text(
                    context.read<GameSessionProvider>().error!,
                    style: const TextStyle(color: Colors.red),
                  ),
                ),
            ],
          ),
        ),
      ),
    );
  }

  Future<void> _startGame() async {
    if (!_formKey.currentState!.validate()) return;

    setState(() => _isProcessing = true);

    try {
      await context.read<GameSessionProvider>().createGameSession(
            _player1Controller.text.trim(),
            _player2Controller.text.trim(),
          );

      if (!mounted) return;
      String sessionId = context.read<GameSessionProvider>().currentSession!.id;
      // Navigate to monitoring screen
      Navigator.of(context).pushReplacement(
        MaterialPageRoute(
          builder: (_) =>  GameMonitoringScreen(sessionId: sessionId),
        ),
      );
    } finally {
      if (mounted) {
        setState(() => _isProcessing = false);
      }
    }
  }
}
```\n
\n### src/themes/app_theme.dart\n
```dart
import 'package:flutter/material.dart';

class AppTheme {
  static ThemeData get theme => ThemeData(
    // Theme configuration will go here
  );
}
```\n
\n### src/services/firebase_service.dart\n
```dart
// lib/src/services/firebase_service.dart
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:uuid/uuid.dart';
import '../models/game_session.dart';

class FirebaseService {
  final FirebaseFirestore _firestore = FirebaseFirestore.instanceFor(
    app: FirebaseFirestore.instance.app,
    databaseId: "scrabble",
  );
  final _uuid = const Uuid();

  // Update session QR code
  Future<GameSession> updateSessionQRCode(
    String sessionId,
    String qrCode,
  ) async {
    await _firestore
        .collection('game_sessions')
        .doc(sessionId)
        .update({'qrCode': qrCode});

    final doc =
        await _firestore.collection('game_sessions').doc(sessionId).get();

    return _parseSessionDoc(doc);
  }

  // Update session status
  Future<void> updateSessionStatus(
    String sessionId,
    bool isActive,
  ) async {
    await _firestore
        .collection('game_sessions')
        .doc(sessionId)
        .update({'isActive': isActive});
  }

  // Get session by ID
  Future<GameSession> getSession(String sessionId) async {
    final doc =
        await _firestore.collection('game_sessions').doc(sessionId).get();

    if (!doc.exists) {
      throw Exception('Session not found');
    }

    return _parseSessionDoc(doc);
  }

  // Get active sessions
  Stream<List<GameSession>> getActiveSessions() {
    return _firestore
        .collection('game_sessions')
        .where('isActive', isEqualTo: true)
        .orderBy('startTime', descending: true)
        .snapshots()
        .map((snapshot) {
      return snapshot.docs.map((doc) => _parseSessionDoc(doc)).toList();
    });
  }

  // Parse Firestore document to GameSession
  GameSession _parseSessionDoc(DocumentSnapshot doc) {
    final data = doc.data() as Map<String, dynamic>;
    final timestamp = data['startTime'] as Timestamp;

    return GameSession(
      id: doc.id,
      player1Name: data['player1Name'],
      player2Name: data['player2Name'],
      startTime: timestamp.toDate(),
      qrCode: data['qrCode'],
      isActive: data['isActive'] ?? false,
    );
  }

// Get real-time board state updates
  Stream<Map<String, dynamic>> getBoardState(String sessionId) {
    return _firestore
        .collection('game_sessions')
        .doc(sessionId)
        .collection('board_state')
        .doc('current')
        .snapshots()
        .map((snapshot) {
      if (!snapshot.exists) {
        return {};
      }
      return snapshot.data() as Map<String, dynamic>;
    });
  }

  // Get real-time session moves
  Stream<List<Map<String, dynamic>>> getSessionMoves(String sessionId) {
    return _firestore
        .collection('game_sessions')
        .doc(sessionId)
        .collection('moves')
        .orderBy('timestamp', descending: false)
        .snapshots()
        .map((snapshot) {
      return snapshot.docs.map((doc) {
        final data = doc.data();
        // Convert Timestamp to DateTime
        if (data['timestamp'] is Timestamp) {
          data['timestamp'] = (data['timestamp'] as Timestamp).toDate();
        }
        return data;
      }).toList();
    });
  }

  // Get real-time player score
  Stream<int> getPlayerScore(String sessionId, String playerId) {
    return _firestore
        .collection('game_sessions')
        .doc(sessionId)
        .collection('moves')
        .where('playerId', isEqualTo: playerId)
        .snapshots()
        .map((snapshot) {
      return snapshot.docs.fold<int>(
        0,
        (sum, doc) => sum + (doc.data()['score'] as int? ?? 0),
      );
    });
  }

  // Update board state
  Future<void> updateBoardState(
      String sessionId, Map<String, dynamic> boardState) async {
    await _firestore
        .collection('game_sessions')
        .doc(sessionId)
        .collection('board_state')
        .doc('current')
        .set(boardState, SetOptions(merge: true));
  }

  // Update player score (if needed separately from moves)
  Future<void> updatePlayerScore(
      String sessionId, String playerId, int score) async {
    await _firestore.collection('game_sessions').doc(sessionId).update({
      'scores.$playerId': FieldValue.increment(score),
    });
  }

  // Get single move by ID
  Future<Map<String, dynamic>?> getMove(String sessionId, String moveId) async {
    final doc = await _firestore
        .collection('game_sessions')
        .doc(sessionId)
        .collection('moves')
        .doc(moveId)
        .get();

    if (!doc.exists) return null;

    final data = doc.data()!;
    if (data['timestamp'] is Timestamp) {
      data['timestamp'] = (data['timestamp'] as Timestamp).toDate();
    }
    return data;
  }

  // Switch to next player's turn
  Future<void> switchTurn(String sessionId) async {
    final session = await getSession(sessionId);
    final nextPlayerId = session.getNextPlayerId();

    await _firestore
        .collection('game_sessions')
        .doc(sessionId)
        .update({'currentPlayerId': nextPlayerId});
  }

  // Update your createGameSession method to include currentPlayerId
  Future<GameSession> createGameSession({
    required String player1Name,
    required String player2Name,
  }) async {
    final sessionId = _uuid.v4();
    final sessionData = {
      'id': sessionId,
      'player1Name': player1Name,
      'player2Name': player2Name,
      'startTime': FieldValue.serverTimestamp(),
      'isActive': true,
      'currentPlayerId': 'p1', // Start with player 1
      'createdAt': FieldValue.serverTimestamp(),
    };

    await _firestore
        .collection('game_sessions')
        .doc(sessionId)
        .set(sessionData);

    return GameSession(
      id: sessionId,
      player1Name: player1Name,
      player2Name: player2Name,
      startTime: DateTime.now(),
      currentPlayerId: 'p1',
      isActive: true,
    );
  }

  // Update your addMoveToSession method to handle turn switching
  Future<void> addMoveToSession({
    required String sessionId,
    required String word,
    required int score,
    required String playerId,
    required List<Map<String, dynamic>> tiles,
  }) async {
    final batch = _firestore.batch();

    // Add the move
    final moveRef = _firestore
        .collection('game_sessions')
        .doc(sessionId)
        .collection('moves')
        .doc();

    batch.set(moveRef, {
      'word': word,
      'score': score,
      'playerId': playerId,
      'tiles': tiles,
      'timestamp': FieldValue.serverTimestamp(),
    });

    // Switch to next player
    final sessionRef = _firestore.collection('game_sessions').doc(sessionId);

    final session = await getSession(sessionId);
    batch.update(sessionRef, {
      'currentPlayerId': session.getNextPlayerId(),
    });

    await batch.commit();
  }

  Stream<QuerySnapshot> getGameSessions() {
    return _firestore
        .collection('game_sessions')
        .orderBy('startTime', descending: true)
        .snapshots();
  }

  // Delete a session and all its subcollections
  Future<void> deleteSession(String sessionId) async {
    // Delete moves subcollection
    final movesSnapshot = await _firestore
        .collection('game_sessions')
        .doc(sessionId)
        .collection('moves')
        .get();

    final batch = _firestore.batch();

    for (var doc in movesSnapshot.docs) {
      batch.delete(doc.reference);
    }

    // Delete main session document
    batch.delete(_firestore.collection('game_sessions').doc(sessionId));

    await batch.commit();
  }

  // Get remaining letters
  Future<int> getRemainingLetters(String sessionId) async {
    final doc = await _firestore
        .collection('game_sessions')
        .doc(sessionId)
        .collection('game_state')
        .doc('letters')
        .get();

    if (!doc.exists) {
      return 0;
    }

    final data = doc.data() as Map<String, dynamic>;
    return data['remaining'] ?? 0;
  }
}
```\n
\n### src/services/gemini_service.dart\n
```dart
import 'dart:convert';
import 'dart:io';

import 'package:google_generative_ai/google_generative_ai.dart';
import 'package:oloodi_scrabble_moderator_app/src/config/env_config.dart';
import 'package:oloodi_scrabble_moderator_app/src/services/firebase_service.dart';

class GeminiService {
  static const String _apiKey = 'YOUR_GEMINI_API_KEY';
  late GenerativeModel _model;
  final FirebaseService _firebaseService = FirebaseService();

  GeminiService() {
    _model = GenerativeModel(
      model: 'gemini-1.5-pro',
      apiKey: EnvConfig.geminiApiKey,
      generationConfig: GenerationConfig(
        temperature: 1,
        topK: 40,
        topP: 0.95,
        maxOutputTokens: 8192,
        responseMimeType: 'text/plain',
      ),
    );
  }

  Future<Map<String, dynamic>> analyzeBoardImage(
    String sessionId,
    String imagePath,
  ) async {
    try {
      // Get previous board state
      final currentBoard = await _firebaseService.getBoardState(sessionId);
      final isFirstMove = await currentBoard.isEmpty;

      // Prepare Gemini prompt
      final prompt = isFirstMove
          ? '''
          Analyze this initial Scrabble board image. Return JSON with:
          {
            "board": [[15x15 grid with letters or "-" for empty]],
            "letters": [
              {"letter": "A", "row": 0, "col": 0, "points": 1},
              ...
            ]
          }
          '''
          : '''
          Compare with previous board state (${currentBoard.toString()}). 
          Identify new letters. Return JSON with:
          {
            "word": "main_word",
            "letters": [
              {"letter": "A", "row": 0, "col": 0, "points": 1},
              ...
            ],
            "score": 12
          }
          ''';

      // Process image
      final imageBytes = await File(imagePath).readAsBytes();

      final response = await _model.generateContent([
        Content.multi([
          TextPart(prompt),
          DataPart('image/jpeg', imageBytes),
        ]),
      ]);

      return _parseResponse(response.text ?? '', isFirstMove);
    } catch (e) {
      return {'status': 'error', 'message': e.toString()};
    }
  }

  Map<String, dynamic> _parseResponse(String response, bool isFirstMove) {
    try {
      final jsonData = jsonDecode(response);

      if (isFirstMove) {
        return {
          'status': 'success',
          'type': 'initial',
          'board': jsonData['board'],
          'letters': List<Map<String, dynamic>>.from(jsonData['letters']),
        };
      }

      return {
        'status': 'success',
        'type': 'move',
        'word': jsonData['word'],
        'score': jsonData['score'],
        'letters': List<Map<String, dynamic>>.from(jsonData['letters']),
      };
    } catch (e) {
      return {'status': 'error', 'message': 'Invalid response format'};
    }
  }
}
```\n
\n### src/services/qr_service.dart\n
```dart
// lib/src/services/qr_service.dart
import 'dart:convert';
import 'package:qr_flutter/qr_flutter.dart';
import 'package:flutter/material.dart';

class QRService {
  // Generate QR code data
  String generateQRCodeData(String sessionId) {
    final data = {
      'sessionId': sessionId,
      'timestamp': DateTime.now().toIso8601String(),
      'type': 'scrabble_game',
    };
    
    return jsonEncode(data);
  }

  // Generate QR code widget
  Widget generateQRCode(String sessionId, {double size = 200}) {
    final data = generateQRCodeData(sessionId);
    
    return QrImageView(
      data: data,
      version: QrVersions.auto,
      size: size,
      backgroundColor: Colors.white,
    );
  }
}

// lib/src/screens/qr_display_screen.dart
class QRDisplayScreen extends StatelessWidget {
  final String sessionId;
  final QRService _qrService = QRService();

  QRDisplayScreen({
    super.key,
    required this.sessionId,
  });

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Connect to Game'),
      ),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Card(
              elevation: 4,
              child: Padding(
                padding: const EdgeInsets.all(16.0),
                child: Column(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    _qrService.generateQRCode(sessionId, size: 250),
                    const SizedBox(height: 16),
                    const Text(
                      'Scan this code with the Companion App',
                      style: TextStyle(fontSize: 16),
                    ),
                    const SizedBox(height: 8),
                    Text(
                      'Session ID: $sessionId',
                      style: const TextStyle(
                        fontSize: 12,
                        color: Colors.grey,
                      ),
                    ),
                  ],
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }
}```\n
\n### src/widgets/board_preview_widget.dart\n
```dart
// lib/src/widgets/board_preview_widget.dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../providers/game_session_provider.dart';
import '../services/firebase_service.dart';

class BoardPreviewWidget extends StatelessWidget {
  const BoardPreviewWidget({super.key});

  @override
  Widget build(BuildContext context) {
    return Card(
      margin: const EdgeInsets.all(16),
      child: Consumer<GameSessionProvider>(
        builder: (context, provider, child) {
          return StreamBuilder<Map<String, dynamic>>(
            stream: FirebaseService().getBoardState(provider.currentSession!.id),
            builder: (context, snapshot) {
              if (snapshot.hasError) {
                return Center(child: Text('Error: ${snapshot.error}'));
              }

              if (!snapshot.hasData) {
                return const Center(child: CircularProgressIndicator());
              }

              final boardState = snapshot.data!;
              return GridView.builder(
                physics: const NeverScrollableScrollPhysics(),
                gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
                  crossAxisCount: 15,
                  childAspectRatio: 1,
                ),
                itemCount: 225, // 15x15 grid
                itemBuilder: (context, index) {
                  final row = index ~/ 15;
                  final col = index % 15;
                  return _buildSquare(context, boardState, row, col);
                },
              );
            },
          );
        },
      ),
    );
  }

  Widget _buildSquare(BuildContext context, Map<String, dynamic> boardState, int row, int col) {
    final squareData = boardState['$row-$col'] as Map<String, dynamic>?;

    return Container(
      decoration: BoxDecoration(
        border: Border.all(color: Colors.black12),
        color: _getSquareColor(squareData?['type'] ?? 'normal'),
      ),
      child: squareData?['letter'] != null
          ? _buildTile(context, squareData!)
          : _buildSquareContent(squareData?['type'] ?? 'normal'),
    );
  }

  Widget _buildTile(BuildContext context, Map<String, dynamic> tileData) {
    return Container(
      margin: const EdgeInsets.all(1),
      decoration: BoxDecoration(
        color: const Color(0xFFF7D698),
        borderRadius: BorderRadius.circular(4),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.2),
            blurRadius: 2,
            offset: const Offset(1, 1),
          ),
        ],
      ),
      child: Stack(
        children: [
          Center(
            child: Text(
              tileData['letter'],
              style: const TextStyle(
                fontSize: 14,
                fontWeight: FontWeight.bold,
              ),
            ),
          ),
          Positioned(
            right: 2,
            bottom: 1,
            child: Text(
              '${tileData['points']}',
              style: const TextStyle(
                fontSize: 8,
                fontWeight: FontWeight.bold,
                color: Colors.black54,
              ),
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildSquareContent(String type) {
    String label = '';
    switch (type) {
      case 'tripleWord':
        label = 'TW';
        break;
      case 'doubleWord':
        label = 'DW';
        break;
      case 'tripleLetter':
        label = 'TL';
        break;
      case 'doubleLetter':
        label = 'DL';
        break;
      case 'center':
        label = 'â˜…';
        break;
      default:
        return const SizedBox();
    }

    return Center(
      child: Text(
        label,
        style: const TextStyle(
          fontSize: 10,
          fontWeight: FontWeight.bold,
          color: Colors.black54,
        ),
      ),
    );
  }

  Color _getSquareColor(String type) {
    switch (type) {
      case 'tripleWord':
        return Colors.red[100]!;
      case 'doubleWord':
        return Colors.pink[50]!;
      case 'tripleLetter':
        return Colors.blue[100]!;
      case 'doubleLetter':
        return Colors.lightBlue[50]!;
      case 'center':
        return Colors.pink[50]!;
      default:
        return Colors.white;
    }
  }
}```\n
\n### src/widgets/move_history_widget.dart\n
```dart
// lib/src/widgets/move_history_widget.dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:intl/intl.dart';
import '../providers/game_session_provider.dart';
import '../services/firebase_service.dart';

class MoveHistoryWidget extends StatelessWidget {
  const MoveHistoryWidget({super.key});

  @override
  Widget build(BuildContext context) {
    return Card(
      margin: const EdgeInsets.all(16),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.stretch,
        children: [
          Container(
            padding: const EdgeInsets.all(16),
            decoration: BoxDecoration(
              border: Border(
                bottom: BorderSide(
                  color: Theme.of(context).dividerColor,
                ),
              ),
            ),
            child: const Text(
              'Move History',
              style: TextStyle(
                fontSize: 18,
                fontWeight: FontWeight.bold,
              ),
            ),
          ),
          Expanded(
            child: _buildMoveList(),
          ),
        ],
      ),
    );
  }

  Widget _buildMoveList() {
    return Consumer<GameSessionProvider>(
      builder: (context, provider, child) {
        return StreamBuilder<List<Map<String, dynamic>>>(
          stream: FirebaseService().getSessionMoves(provider.currentSession!.id),
          builder: (context, snapshot) {
            if (snapshot.hasError) {
              return Center(child: Text('Error: ${snapshot.error}'));
            }

            if (!snapshot.hasData) {
              return const Center(child: CircularProgressIndicator());
            }

            final moves = snapshot.data!;
            if (moves.isEmpty) {
              return const Center(child: Text('No moves yet'));
            }

            return ListView.builder(
              itemCount: moves.length,
              itemBuilder: (context, index) {
                final move = moves[index];
                return _buildMoveItem(context, move, index + 1);
              },
            );
          },
        );
      },
    );
  }

  Widget _buildMoveItem(BuildContext context, Map<String, dynamic> move, int moveNumber) {
    final timestamp = move['timestamp'] as DateTime;
    final isPlayer1 = move['playerId'] == 'p1';
    final provider = context.read<GameSessionProvider>();
    final playerName = isPlayer1 
        ? provider.currentSession!.player1Name 
        : provider.currentSession!.player2Name;

    return ListTile(
      leading: CircleAvatar(
        backgroundColor: isPlayer1 ? Colors.blue[300] : Colors.green[300],
        child: Text(
          move['word'][0],
          style: const TextStyle(color: Colors.white),
        ),
      ),
      title: Text(move['word']),
      subtitle: Text('$playerName - ${move['score']} points'),
      trailing: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        crossAxisAlignment: CrossAxisAlignment.end,
        children: [
          Text(
            '#$moveNumber',
            style: Theme.of(context).textTheme.bodySmall,
          ),
          Text(
            DateFormat.jm().format(timestamp),
            style: Theme.of(context).textTheme.bodySmall,
          ),
        ],
      ),
      onTap: () => _showMoveDetails(context, move),
    );
  }

  void _showMoveDetails(BuildContext context, Map<String, dynamic> move) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: Text('Move #${move['word']}'),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text('Score: ${move['score']} points'),
            const SizedBox(height: 8),
            Text('Player: ${move['playerId'] == 'p1' ? 'Player 1' : 'Player 2'}'),
            const SizedBox(height: 8),
            Text('Time: ${DateFormat.jm().format(move['timestamp'] as DateTime)}'),
            if (move['tiles'] != null) ...[
              const SizedBox(height: 16),
              const Text('Tiles placed:'),
              const SizedBox(height: 8),
              Wrap(
                spacing: 8,
                children: [
                  for (final tile in move['tiles'])
                    Chip(
                      label: Text('${tile['letter']} (${tile['points']})'),
                    ),
                ],
              ),
            ],
          ],
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('Close'),
          ),
        ],
      ),
    );
  }
}```\n
\n### src/widgets/player_info_widget.dart\n
```dart
// lib/src/widgets/player_info_widget.dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../providers/game_session_provider.dart';
import '../services/firebase_service.dart';

class PlayerInfoWidget extends StatelessWidget {
  final String player1Name;
  final String player2Name;

  const PlayerInfoWidget({
    super.key,
    required this.player1Name,
    required this.player2Name,
  });

  @override
  Widget build(BuildContext context) {
    return Card(
      margin: const EdgeInsets.all(16),
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Row(
          children: [
            Expanded(
              child: _buildPlayerInfo(
                context,
                name: player1Name,
                playerId: 'p1',
                color: Colors.blue[300]!,
              ),
            ),
            Container(
              height: 40,
              width: 2,
              color: Colors.grey[300],
            ),
            Expanded(
              child: _buildPlayerInfo(
                context,
                name: player2Name,
                playerId: 'p2',
                color: Colors.green[300]!,
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildPlayerInfo(
    BuildContext context, {
    required String name,
    required String playerId,
    required Color color,
  }) {
    return StreamBuilder<int>(
      stream: FirebaseService().getPlayerScore(
        context.read<GameSessionProvider>().currentSession!.id,
        playerId,
      ),
      builder: (context, snapshot) {
        final score = snapshot.data ?? 0;
        final isCurrentPlayer = context.select(
          (GameSessionProvider p) => p.currentSession?.currentPlayerId == playerId,
        );

        return Container(
          padding: const EdgeInsets.all(8),
          decoration: BoxDecoration(
            borderRadius: BorderRadius.circular(8),
            border: isCurrentPlayer
                ? Border.all(color: color, width: 2)
                : null,
          ),
          child: Column(
            children: [
              Row(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  CircleAvatar(
                    backgroundColor: color,
                    radius: 16,
                    child: Text(
                      name[0],
                      style: const TextStyle(
                        color: Colors.white,
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                  ),
                  const SizedBox(width: 8),
                  Flexible(
                    child: Text(
                      name,
                      style: const TextStyle(
                        fontSize: 16,
                        fontWeight: FontWeight.bold,
                      ),
                      overflow: TextOverflow.ellipsis,
                    ),
                  ),
                ],
              ),
              const SizedBox(height: 8),
              Text(
                'Score: $score',
                style: TextStyle(
                  fontSize: 20,
                  fontWeight: FontWeight.bold,
                  color: color,
                ),
              ),
              if (isCurrentPlayer) ...[
                const SizedBox(height: 4),
                Container(
                  padding: const EdgeInsets.symmetric(
                    horizontal: 8,
                    vertical: 2,
                  ),
                  decoration: BoxDecoration(
                    color: color.withOpacity(0.2),
                    borderRadius: BorderRadius.circular(12),
                  ),
                  child: const Text(
                    'Current Turn',
                    style: TextStyle(fontSize: 12),
                  ),
                ),
              ],
            ],
          ),
        );
      },
    );
  }
}```\n
\n### src/widgets/camera_overlay_widget.dart\n
```dart
```\n
\n## pubspec.yaml\n
```yaml
name: oloodi_scrabble_moderator_app
description: Moderator app for Scrabble game management.
publish_to: 'none'
version: 1.0.0+1

environment:
  sdk: '>=3.0.0 <4.0.0'

dependencies:
  flutter:
    sdk: flutter
  cupertino_icons: ^1.0.2
  provider: ^6.1.1
  firebase_core: ^2.32.0
  cloud_firestore: ^4.13.6
  google_generative_ai: ^0.4.6
  camera: ^0.10.5+9
  qr_flutter: ^4.1.0
  path_provider: ^2.1.5
  uuid: ^4.3.3
  intl: ^0.18.1
  permission_handler: ^11.3.1
  flutter_dotenv: ^5.2.1

dev_dependencies:
  flutter_test:
    sdk: flutter
  flutter_lints: ^3.0.1

flutter:
  uses-material-design: true
  assets:
    - assets/images/
    - assets/icons/
```
