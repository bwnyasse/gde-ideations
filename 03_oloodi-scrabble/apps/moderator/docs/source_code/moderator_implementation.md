# Source Code Documentation
\n## Project Structure\n
\n### firebase_options.dart\n
```dart
// File generated by FlutterFire CLI.
// ignore_for_file: type=lint
import 'package:firebase_core/firebase_core.dart' show FirebaseOptions;
import 'package:flutter/foundation.dart'
    show defaultTargetPlatform, kIsWeb, TargetPlatform;

/// Default [FirebaseOptions] for use with your Firebase apps.
///
/// Example:
/// ```dart
/// import 'firebase_options.dart';
/// // ...
/// await Firebase.initializeApp(
///   options: DefaultFirebaseOptions.currentPlatform,
/// );
/// ```
class DefaultFirebaseOptions {
  static FirebaseOptions get currentPlatform {
    if (kIsWeb) {
      throw UnsupportedError(
        'DefaultFirebaseOptions have not been configured for web - '
        'you can reconfigure this by running the FlutterFire CLI again.',
      );
    }
    switch (defaultTargetPlatform) {
      case TargetPlatform.android:
        return android;
      case TargetPlatform.iOS:
        throw UnsupportedError(
          'DefaultFirebaseOptions have not been configured for ios - '
          'you can reconfigure this by running the FlutterFire CLI again.',
        );
      case TargetPlatform.macOS:
        throw UnsupportedError(
          'DefaultFirebaseOptions have not been configured for macos - '
          'you can reconfigure this by running the FlutterFire CLI again.',
        );
      case TargetPlatform.windows:
        throw UnsupportedError(
          'DefaultFirebaseOptions have not been configured for windows - '
          'you can reconfigure this by running the FlutterFire CLI again.',
        );
      case TargetPlatform.linux:
        throw UnsupportedError(
          'DefaultFirebaseOptions have not been configured for linux - '
          'you can reconfigure this by running the FlutterFire CLI again.',
        );
      default:
        throw UnsupportedError(
          'DefaultFirebaseOptions are not supported for this platform.',
        );
    }
  }

  static const FirebaseOptions android = FirebaseOptions(
    apiKey: 'AIzaSyCHk-o2MoCxroAM5rjhVsGI77RZi2drqfM',
    appId: '1:553140087820:android:a8c79c54f1da5c6ed51229',
    messagingSenderId: '553140087820',
    projectId: 'learning-box-369917',
    storageBucket: 'learning-box-369917.firebasestorage.app',
  );

}```\n
\n### main.dart\n
```dart
import 'package:firebase_storage/firebase_storage.dart';
import 'package:flutter/material.dart';
import 'package:oloodi_scrabble_moderator_app/src/screens/game_sessions_list_screen.dart';
import 'package:provider/provider.dart';
import 'src/providers/game_session_provider.dart';
import 'src/themes/app_theme.dart';
import 'package:firebase_core/firebase_core.dart';
import 'firebase_options.dart';

void main() async {
  WidgetsFlutterBinding.ensureInitialized();
  await Firebase.initializeApp(
    options: DefaultFirebaseOptions.currentPlatform,
  );

  // Initialize Firebase Storage
  FirebaseStorage.instance.setMaxUploadRetryTime(const Duration(seconds: 3));

  runApp(const ModeratorApp());
}

class ModeratorApp extends StatelessWidget {
  const ModeratorApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MultiProvider(
      providers: [
        ChangeNotifierProvider(create: (_) => GameSessionProvider()),
      ],
      child: MaterialApp(
        title: 'Scrabble Moderator',
        theme: AppTheme.theme,
        home: const GameSessionsListScreen(),
      ),
    );
  }
}
```\n
\n### src/config/env_config.dart\n
```dart
// lib/config/env_config.dart
import 'package:flutter_dotenv/flutter_dotenv.dart';

class EnvConfig {
  static String get geminiApiKey {
    try {
      return dotenv.get('GEMINI_API_KEY', fallback: '');
    } catch (e) {
      return '';
    }
  }

  static String get elevenLabsApiKey {
    try {
      return dotenv.get('ELEVEN_LABS_API_KEY', fallback: '');
    } catch (e) {
      return '';
    }
  }

  static String get elevenLabsVoiceId {
    try {
      return dotenv.get('ELEVEN_LABS_VOICE_ID', fallback: '');
    } catch (e) {
      return '';
    }
  }

  static bool get isConfigured {
    return geminiApiKey.isNotEmpty && 
           elevenLabsApiKey.isNotEmpty && 
           elevenLabsVoiceId.isNotEmpty;
  }

  static List<String> getMissingConfigurations() {
    final missing = <String>[];
    
    if (geminiApiKey.isEmpty) {
      missing.add('Gemini API Key');
    }
    if (elevenLabsApiKey.isEmpty) {
      missing.add('ElevenLabs API Key');
    }
    if (elevenLabsVoiceId.isEmpty) {
      missing.add('ElevenLabs Voice ID');
    }
    
    return missing;
  }
}```\n
\n### src/providers/game_session_provider.dart\n
```dart
import 'package:flutter/foundation.dart';
import '../models/game_session.dart';
import '../services/firebase_service.dart';
import '../services/qr_service.dart';

class GameSessionProvider with ChangeNotifier {
  final FirebaseService _firebaseService = FirebaseService();
  final QRService _qrService = QRService();

  GameSession? _currentSession;
  bool _isLoading = false;
  String? _error;

  // Getters
  GameSession? get currentSession => _currentSession;
  bool get isLoading => _isLoading;
  String? get error => _error;
  bool get hasActiveSession =>
      _currentSession != null && _currentSession!.isActive;

  // Create new game session
  Future<void> createGameSession(String player1Name, String player2Name) async {
    try {
      _setLoading(true);
      _clearError();

      // Create session in Firebase
      final session = await _firebaseService.createGameSession(
        player1Name: player1Name,
        player2Name: player2Name,
      );

      // Generate QR code data string
      final qrCodeData = _qrService.generateQRCodeData(session.id);

      // Update session with QR code data
      _currentSession = await _firebaseService.updateSessionQRCode(
        session.id,
        qrCodeData,
      );

      notifyListeners();
    } catch (e) {
      _setError('Failed to create game session: $e');
    } finally {
      _setLoading(false);
    }
  }

  Future<void> addMove({
    required String word,
    required int score,
    required String playerId,
    required List<Map<String, dynamic>> tiles,
    String? imagePath, // Add this parameter
  }) async {
    if (_currentSession == null) {
      _setError('No active session');
      return;
    }

    try {
      _setLoading(true);
      _clearError();

      await _firebaseService.addMoveToSession(
        sessionId: _currentSession!.id,
        word: word,
        score: score,
        playerId: playerId,
        tiles: tiles,
        imagePath: imagePath, // Pass the image path
      );

      notifyListeners();
    } catch (e) {
      _setError('Failed to add move: $e');
    } finally {
      _setLoading(false);
    }
  }

  // Update board state
  Future<void> updateBoardState(
    String sessionId,
    List<Map<String, dynamic>> tiles,
  ) async {
    try {
      _setLoading(true);
      _clearError();

      // Update in Firebase using tiles directly
      await _firebaseService.updateBoardState(sessionId, tiles);

      notifyListeners();
    } catch (e) {
      _setError('Failed to update board state: $e');
      throw e;
    } finally {
      _setLoading(false);
    }
  }

  // Load existing session
  Future<void> loadSession(String sessionId) async {
    try {
      _setLoading(true);
      _clearError();

      _currentSession = await _firebaseService.getSession(sessionId);
      notifyListeners();
    } catch (e) {
      _setError('Failed to load session: $e');
    } finally {
      _setLoading(false);
    }
  }

  // End current session
  Future<void> endCurrentSession() async {
    if (_currentSession == null) return;

    try {
      _setLoading(true);
      _clearError();

      await _firebaseService.updateSessionStatus(
        _currentSession!.id,
        false,
      );

      _currentSession = null;
      notifyListeners();
    } catch (e) {
      _setError('Failed to end session: $e');
    } finally {
      _setLoading(false);
    }
  }

  // Get all sessions
  Stream<List<GameSession>> getSessions() {
    return _firebaseService.getGameSessions().map((snapshot) => snapshot.docs
        .map((doc) => GameSession.fromJson(doc.data() as Map<String, dynamic>))
        .toList());
  }

  // Delete multiple sessions
  Future<void> deleteSessions(List<String> sessionIds) async {
    try {
      _setLoading(true);
      _clearError();

      for (final sessionId in sessionIds) {
        await _firebaseService.deleteSession(sessionId);
      }
    } catch (e) {
      _setError('Failed to delete sessions: $e');
      rethrow;
    } finally {
      _setLoading(false);
    }
  }

  // Get session statistics
  Future<Map<String, dynamic>> getSessionStats(String sessionId) async {
    try {
      final moves = await _firebaseService.getSessionMoves(sessionId).first;
      final remainingLetters =
          await _firebaseService.getRemainingLetters(sessionId);

      return {
        'totalMoves': moves.length,
        'remainingLetters': remainingLetters,
        'player1Score': moves
            .where((m) => m['playerId'] == 'p1')
            .fold(0, (sum, m) => sum + (m['score'] as int)),
        'player2Score': moves
            .where((m) => m['playerId'] == 'p2')
            .fold(0, (sum, m) => sum + (m['score'] as int)),
      };
    } catch (e) {
      _setError('Failed to get session stats: $e');
      rethrow;
    }
  }

  // Helper methods
  void _setLoading(bool loading) {
    _isLoading = loading;
    notifyListeners();
  }

  void _setError(String error) {
    _error = error;
    notifyListeners();
  }

  void _clearError() {
    _error = null;
  }

    Future<void> switchCurrentPlayer(String playerId) async {
    if (_currentSession == null) {
      _setError('No active session');
      return;
    }

    try {
      _setLoading(true);
      _clearError();

      // Update current player in Firebase
      await _firebaseService.switchCurrentPlayer(
        _currentSession!.id,
        playerId,
      );

      // Reload session to get updated state
      await loadSession(_currentSession!.id);

      notifyListeners();
    } catch (e) {
      _setError('Failed to switch player: $e');
    } finally {
      _setLoading(false);
    }
  }
}
```\n
\n### src/models/game_session.g.dart\n
```dart
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'game_session.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

Move _$MoveFromJson(Map<String, dynamic> json) => Move(
      word: json['word'] as String,
      score: (json['score'] as num).toInt(),
      tiles: (json['tiles'] as List<dynamic>)
          .map((e) => e as Map<String, dynamic>)
          .toList(),
      playerId: json['playerId'] as String,
      timestamp: Move._timestampFromJson(json['timestamp'] as Timestamp),
      imagePath: json['imagePath'] as String?,
    );

Map<String, dynamic> _$MoveToJson(Move instance) => <String, dynamic>{
      'word': instance.word,
      'score': instance.score,
      'tiles': instance.tiles,
      'playerId': instance.playerId,
      'timestamp': Move._timestampToJson(instance.timestamp),
      'imagePath': instance.imagePath,
    };

GameSession _$GameSessionFromJson(Map<String, dynamic> json) => GameSession(
      id: json['id'] as String,
      player1Name: json['player1Name'] as String,
      player2Name: json['player2Name'] as String,
      startTime: GameSession._timestampFromJson(json['startTime'] as Timestamp),
      qrCode: json['qrCode'] as String?,
      currentPlayerId: json['currentPlayerId'] as String? ?? 'p1',
      moves: (json['moves'] as List<dynamic>?)
              ?.map((e) => Move.fromJson(e as Map<String, dynamic>))
              .toList() ??
          [],
      isActive: json['isActive'] as bool? ?? true,
    );

Map<String, dynamic> _$GameSessionToJson(GameSession instance) =>
    <String, dynamic>{
      'id': instance.id,
      'player1Name': instance.player1Name,
      'player2Name': instance.player2Name,
      'startTime': GameSession._timestampToJson(instance.startTime),
      'qrCode': instance.qrCode,
      'currentPlayerId': instance.currentPlayerId,
      'moves': instance.moves,
      'isActive': instance.isActive,
    };
```\n
\n### src/models/game_session.dart\n
```dart
// move.dart
import 'package:json_annotation/json_annotation.dart';
import 'package:cloud_firestore/cloud_firestore.dart';

part 'game_session.g.dart';

@JsonSerializable()
class Move {
  final String word;
  final int score;
  final List<Map<String, dynamic>> tiles;
  final String playerId;
  @JsonKey(fromJson: _timestampFromJson, toJson: _timestampToJson)
  final DateTime timestamp;
  final String? imagePath;

  Move({
    required this.word,
    required this.score,
    required this.tiles,
    required this.playerId,
    required this.timestamp,
    this.imagePath,
  });

  factory Move.fromJson(Map<String, dynamic> json) => _$MoveFromJson(json);
  Map<String, dynamic> toJson() => _$MoveToJson(this);

  static DateTime _timestampFromJson(Timestamp timestamp) => timestamp.toDate();
  static Timestamp _timestampToJson(DateTime date) => Timestamp.fromDate(date);
}

@JsonSerializable()
class GameSession {
  final String id;
  final String player1Name;
  final String player2Name;
  @JsonKey(fromJson: _timestampFromJson, toJson: _timestampToJson)
  final DateTime startTime;
  final String? qrCode;
  final String currentPlayerId;
  @JsonKey(defaultValue: [])
  final List<Move> moves;
  final bool isActive;

  GameSession({
    required this.id,
    required this.player1Name,
    required this.player2Name,
    required this.startTime,
    this.qrCode,
    this.currentPlayerId = 'p1',
    this.moves = const [],
    this.isActive = true,
  });

  factory GameSession.fromJson(Map<String, dynamic> json) =>
      _$GameSessionFromJson(json);
  Map<String, dynamic> toJson() => _$GameSessionToJson(this);

  static DateTime _timestampFromJson(Timestamp timestamp) => timestamp.toDate();
  static Timestamp _timestampToJson(DateTime date) => Timestamp.fromDate(date);

  String getNextPlayerId() => currentPlayerId == 'p1' ? 'p2' : 'p1';
  Move? get lastMove => moves.isNotEmpty ? moves.last : null;
}```\n
\n### src/models/board_square.dart\n
```dart
// lib/src/models/board_square.dart
enum SquareType {
  normal,
  doubleLetter,
  tripleLetter,
  doubleWord,
  tripleWord,
  center
}

class BoardSquare {
  final int row;
  final int col;
  final SquareType type;
  Map<String, dynamic>? tile;

  BoardSquare({
    required this.row,
    required this.col,
    required this.type,
    this.tile,
  });

  // Convert from string type (used in Firebase) to SquareType
  static SquareType typeFromString(String type) {
    switch (type) {
      case 'tripleWord':
        return SquareType.tripleWord;
      case 'doubleWord':
        return SquareType.doubleWord;
      case 'tripleLetter':
        return SquareType.tripleLetter;
      case 'doubleLetter':
        return SquareType.doubleLetter;
      case 'center':
        return SquareType.center;
      default:
        return SquareType.normal;
    }
  }

  // Convert from SquareType to string (for Firebase)
  static String typeToString(SquareType type) {
    switch (type) {
      case SquareType.tripleWord:
        return 'tripleWord';
      case SquareType.doubleWord:
        return 'doubleWord';
      case SquareType.tripleLetter:
        return 'tripleLetter';
      case SquareType.doubleLetter:
        return 'doubleLetter';
      case SquareType.center:
        return 'center';
      default:
        return 'normal';
    }
  }
}```\n
\n### src/screens/game_monitoring_screen.dart\n
```dart
// lib/src/screens/game_monitoring_screen.dart
import 'package:flutter/material.dart';
import 'package:oloodi_scrabble_moderator_app/src/services/qr_service.dart';
import 'package:oloodi_scrabble_moderator_app/src/widgets/recognition_metrics_viewer.dart';
import 'package:provider/provider.dart';
import '../providers/game_session_provider.dart';
import '../widgets/move_history_widget.dart';
import '../widgets/player_info_widget.dart';
import 'move_capture_screen.dart';

class GameMonitoringScreen extends StatelessWidget {
  final String sessionId;

  const GameMonitoringScreen({
    super.key,
    required this.sessionId,
  });

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Game Monitoring'),
        actions: [
          IconButton(
            icon: const Icon(Icons.qr_code),
            onPressed: () => _showQRCode(context),
          ),
          IconButton(
            icon: const Icon(Icons.stop),
            onPressed: () => _endGame(context),
          ),
          IconButton(
            icon: const Icon(Icons.analytics),
            onPressed: () => showDialog(
              context: context,
              builder: (_) => Dialog(
                child: SizedBox(
                  width: 400,
                  height: 600,
                  child: MetricsViewer(sessionId: sessionId),
                ),
              ),
            ),
          ),
        ],
      ),
      body: FutureBuilder<void>(
        future: context.read<GameSessionProvider>().loadSession(sessionId),
        builder: (context, snapshot) {
          if (snapshot.hasError) {
            return Center(child: Text('Error: ${snapshot.error}'));
          }

          return Consumer<GameSessionProvider>(
            builder: (context, provider, child) {
              if (provider.isLoading) {
                return const Center(child: CircularProgressIndicator());
              }

              if (provider.error != null) {
                return Center(child: Text(provider.error!));
              }

              if (provider.currentSession == null) {
                return const Center(child: Text('Session not found'));
              }

              return Column(
                children: [
                  // Player information with selection handlers
                  PlayerInfoWidget(
                    player1Name: provider.currentSession!.player1Name,
                    player2Name: provider.currentSession!.player2Name,
                    onPlayer1Selected: () => _selectPlayer(context, 'p1'),
                    onPlayer2Selected: () => _selectPlayer(context, 'p2'),
                  ),

                  // Move history
                  const Expanded(
                    child: MoveHistoryWidget(),
                  ),
                ],
              );
            },
          );
        },
      ),
      floatingActionButton: FloatingActionButton.extended(
        onPressed: () => _captureMove(context),
        icon: const Icon(Icons.camera_alt),
        label: const Text('Capture Move'),
      ),
    );
  }

  Future<void> _selectPlayer(BuildContext context, String playerId) async {
    try {
      // Get the current session
      final provider = context.read<GameSessionProvider>();
      final session = provider.currentSession;

      if (session == null) {
        throw Exception('No active session');
      }

      // Only allow changing to a different player
      if (session.currentPlayerId != playerId) {
        // Update current player
        await provider.switchCurrentPlayer(playerId);

        if (context.mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text(
                  'Switched to ${playerId == 'p1' ? 'Player 1' : 'Player 2'}\'s turn'),
            ),
          );
        }
      }
    } catch (e) {
      if (context.mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error switching player: $e'),
            backgroundColor: Colors.red,
          ),
        );
      }
    }
  }

  void _showQRCode(BuildContext context) {
    Navigator.push(
      context,
      MaterialPageRoute(
        builder: (_) => QRDisplayScreen(sessionId: sessionId),
      ),
    );
  }

  void _captureMove(BuildContext context) {
    Navigator.push(
      context,
      MaterialPageRoute(
        builder: (_) => const MoveCaptureScreen(),
      ),
    );
  }

  Future<void> _endGame(BuildContext context) async {
    final confirmed = await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('End Game'),
        content: const Text('Are you sure you want to end this game?'),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context, false),
            child: const Text('Cancel'),
          ),
          TextButton(
            onPressed: () => Navigator.pop(context, true),
            child: const Text('End Game'),
          ),
        ],
      ),
    );

    if (confirmed != true || !context.mounted) return;

    try {
      await context.read<GameSessionProvider>().endCurrentSession();
      if (!context.mounted) return;
      Navigator.of(context).popUntil((route) => route.isFirst);
    } catch (e) {
      if (!context.mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Failed to end game: $e')),
      );
    }
  }
}
```\n
\n### src/screens/game_sessions_list_screen.dart\n
```dart
// lib/src/screens/game_sessions_list_screen.dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:intl/intl.dart';
import '../providers/game_session_provider.dart';
import '../models/game_session.dart';
import 'game_setup_screen.dart';
import 'game_monitoring_screen.dart';

class GameSessionsListScreen extends StatefulWidget {
  const GameSessionsListScreen({super.key});

  @override
  State<GameSessionsListScreen> createState() => _GameSessionsListScreenState();
}

class _GameSessionsListScreenState extends State<GameSessionsListScreen> {
  final Set<String> _selectedSessions = {};

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Game Sessions'),
        actions: [
          if (_selectedSessions.isNotEmpty)
            IconButton(
              icon: const Icon(Icons.delete),
              onPressed: _deleteSelectedSessions,
            ),
        ],
      ),
      body: StreamBuilder<List<GameSession>>(
        stream: context.read<GameSessionProvider>().getSessions(),
        builder: (context, snapshot) {
          if (snapshot.hasError) {
            return Center(
              child: Text('Error: ${snapshot.error}'),
            );
          }

          if (snapshot.connectionState == ConnectionState.waiting) {
            return const Center(
              child: CircularProgressIndicator(),
            );
          }

          final sessions = snapshot.data ?? [];
          if (sessions.isEmpty) {
            return Center(
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  const Icon(Icons.sports_esports_outlined, size: 64, color: Colors.grey),
                  const SizedBox(height: 16),
                  const Text(
                    'No game sessions yet',
                    style: TextStyle(fontSize: 18, color: Colors.grey),
                  ),
                  const SizedBox(height: 8),
                  const Text(
                    'Create a new game to get started',
                    style: TextStyle(color: Colors.grey),
                  ),
                ],
              ),
            );
          }

          return ListView.builder(
            itemCount: sessions.length,
            itemBuilder: (context, index) {
              final session = sessions[index];
              return _buildSessionCard(session);
            },
          );
        },
      ),
      floatingActionButton: FloatingActionButton.extended(
        onPressed: () => _navigateToGameSetup(context),
        icon: const Icon(Icons.add),
        label: const Text('Start Game'),
      ),
    );
  }

  Widget _buildSessionCard(GameSession session) {
    final dateFormat = DateFormat('MMM d, y â€“ h:mm a');
    final isSelected = _selectedSessions.contains(session.id);

    return Card(
      margin: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
      child: InkWell(
        onTap: () => _navigateToSession(session),
        onLongPress: () => _toggleSessionSelection(session.id),
        child: Container(
          padding: const EdgeInsets.all(16),
          color: isSelected ? Colors.blue.withOpacity(0.1) : null,
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Row(
                children: [
                  Expanded(
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Row(
                          children: [
                            Text(
                              '${session.player1Name} vs ${session.player2Name}',
                              style: const TextStyle(
                                fontSize: 16,
                                fontWeight: FontWeight.bold,
                              ),
                            ),
                            if (session.isActive)
                              Container(
                                margin: const EdgeInsets.only(left: 8),
                                padding: const EdgeInsets.symmetric(
                                  horizontal: 8,
                                  vertical: 2,
                                ),
                                decoration: BoxDecoration(
                                  color: Colors.green,
                                  borderRadius: BorderRadius.circular(12),
                                ),
                                child: const Text(
                                  'Active',
                                  style: TextStyle(
                                    color: Colors.white,
                                    fontSize: 12,
                                  ),
                                ),
                              ),
                          ],
                        ),
                        const SizedBox(height: 4),
                        Text(
                          dateFormat.format(session.startTime),
                          style: TextStyle(
                            color: Colors.grey[600],
                            fontSize: 12,
                          ),
                        ),
                      ],
                    ),
                  ),
                  if (isSelected)
                    const Icon(Icons.check_circle, color: Colors.blue)
                  else
                    const Icon(Icons.chevron_right, color: Colors.grey),
                ],
              ),
              if (session.isActive) ...[
                const SizedBox(height: 16),
                _buildGameStats(session),
              ],
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildGameStats(GameSession session) {
    return FutureBuilder<Map<String, dynamic>>(
      future: context.read<GameSessionProvider>().getSessionStats(session.id),
      builder: (context, snapshot) {
        if (!snapshot.hasData) {
          return const SizedBox();
        }

        final stats = snapshot.data!;
        return Row(
          mainAxisAlignment: MainAxisAlignment.spaceAround,
          children: [
            _buildStatItem('Moves', stats['totalMoves']?.toString() ?? '0'),
            _buildStatItem('Letters Remaining', stats['remainingLetters']?.toString() ?? '-'),
            _buildStatItem('Duration', _formatDuration(session.startTime)),
          ],
        );
      },
    );
  }

  Widget _buildStatItem(String label, String value) {
    return Column(
      children: [
        Text(
          value,
          style: const TextStyle(
            fontSize: 16,
            fontWeight: FontWeight.bold,
          ),
        ),
        Text(
          label,
          style: TextStyle(
            fontSize: 12,
            color: Colors.grey[600],
          ),
        ),
      ],
    );
  }

  String _formatDuration(DateTime startTime) {
    final duration = DateTime.now().difference(startTime);
    final hours = duration.inHours;
    final minutes = duration.inMinutes % 60;
    return '${hours}h ${minutes}m';
  }

  void _toggleSessionSelection(String sessionId) {
    setState(() {
      if (_selectedSessions.contains(sessionId)) {
        _selectedSessions.remove(sessionId);
      } else {
        _selectedSessions.add(sessionId);
      }
    });
  }

  Future<void> _deleteSelectedSessions() async {
    final confirmed = await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Delete Sessions'),
        content: Text(
          'Are you sure you want to delete ${_selectedSessions.length} selected session(s)?',
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context, false),
            child: const Text('Cancel'),
          ),
          TextButton(
            onPressed: () => Navigator.pop(context, true),
            child: const Text('Delete'),
          ),
        ],
      ),
    );

    if (confirmed == true && mounted) {
      try {
        await context.read<GameSessionProvider>().deleteSessions(_selectedSessions.toList());
        setState(() {
          _selectedSessions.clear();
        });
      } catch (e) {
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(content: Text('Error deleting sessions: $e')),
          );
        }
      }
    }
  }

  void _navigateToSession(GameSession session) {
    Navigator.push(
      context,
      MaterialPageRoute(
        builder: (context) => GameMonitoringScreen(sessionId: session.id),
      ),
    );
  }

  void _navigateToGameSetup(BuildContext context) {
    Navigator.push(
      context,
      MaterialPageRoute(
        builder: (context) => const GameSetupScreen(),
      ),
    );
  }
}```\n
\n### src/screens/qr_display_screen.dart\n
```dart
```\n
\n### src/screens/move_capture_screen.dart\n
```dart
import 'dart:io';

import 'package:camera/camera.dart';
import 'package:flutter/material.dart';
import 'package:image_cropper/image_cropper.dart';
import 'package:oloodi_scrabble_moderator_app/src/services/recognition_metrics_service.dart';
import 'package:oloodi_scrabble_moderator_app/src/widgets/board_overlay_painter.dart';
import 'package:permission_handler/permission_handler.dart';
import 'package:provider/provider.dart';
import '../providers/game_session_provider.dart';
import '../services/gemini_service.dart';

class MoveCaptureScreen extends StatefulWidget {
  const MoveCaptureScreen({super.key});

  @override
  State<MoveCaptureScreen> createState() => _MoveCaptureScreenState();
}

class _MoveCaptureScreenState extends State<MoveCaptureScreen>
    with WidgetsBindingObserver {
  CameraController? _controller;
  bool _isCameraInitialized = false;
  String? _error;
  bool _processing = false;
  final GeminiService _geminiService = GeminiService();
  String? _currentImagePath; // Track the current image path

  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addObserver(this);
    _requestCameraPermission();
  }

  @override
  void dispose() {
    WidgetsBinding.instance.removeObserver(this);
    _controller?.dispose();
    _cleanupTempImage();
    super.dispose();
  }

  // Cleanup temporary image
  Future<void> _cleanupTempImage() async {
    if (_currentImagePath != null) {
      try {
        final file = File(_currentImagePath!);
        if (await file.exists()) {
          await file.delete();
        }
      } catch (e) {
        print('Error cleaning up temp image: $e');
      }
    }
  }

  @override
  void didChangeAppLifecycleState(AppLifecycleState state) {
    if (state == AppLifecycleState.inactive) {
      _controller?.dispose();
    } else if (state == AppLifecycleState.resumed) {
      _initializeCamera();
    }
  }

  Future<void> _requestCameraPermission() async {
    var status = await Permission.camera.request();
    if (mounted) {
      if (status.isGranted) {
        _initializeCamera();
      } else {
        setState(() {
          _error = status.isPermanentlyDenied
              ? 'Camera permission permanently denied. Please enable it in settings.'
              : 'Camera permission is required to capture moves.';
        });
      }
    }
  }

  Future<void> _initializeCamera() async {
    try {
      final cameras = await availableCameras();
      if (cameras.isEmpty) {
        setState(() => _error = 'No cameras available');
        return;
      }

      final controller = CameraController(
        cameras.first,
        ResolutionPreset.max,
        enableAudio: false,
      );

      await controller.initialize();

      if (mounted) {
        setState(() {
          _controller = controller;
          _isCameraInitialized = true;
          _error = null;
        });
      }
    } catch (e) {
      setState(() => _error = 'Error initializing camera: $e');
    }
  }

  Future<void> _captureAndAnalyze() async {
    if (_processing ||
        _controller == null ||
        !_controller!.value.isInitialized) {
      return;
    }

    setState(() => _processing = true);

    try {
      // Clean up previous temp image if exists
      await _cleanupTempImage();

      // Show capturing status
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
              content: Text('Capturing image...'),
              duration: Duration(seconds: 1)),
        );
      }

      // Capture image
      final image = await _controller!.takePicture();

      // Crop image
      final croppedFile = await ImageCropper().cropImage(
        sourcePath: image.path,
        aspectRatio: const CropAspectRatio(ratioX: 1, ratioY: 1),
        compressQuality: 100,
        uiSettings: [
          AndroidUiSettings(
            toolbarTitle: 'Adjust Board Position',
            toolbarColor: Theme.of(context).primaryColor,
            toolbarWidgetColor: Colors.white,
            initAspectRatio: CropAspectRatioPreset.square,
            lockAspectRatio: true,
          ),
          IOSUiSettings(
            title: 'Adjust Board Position',
            aspectRatioLockEnabled: true,
            resetAspectRatioEnabled: false,
          ),
        ],
      );

      if (croppedFile == null) {
        throw Exception('Image cropping cancelled');
      }

      _currentImagePath = croppedFile.path;

      // Get current session details
      final gameState = context.read<GameSessionProvider>();
      final session = gameState.currentSession;

      if (session == null) {
        throw Exception('No active session');
      }

      // Show analyzing status
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
              content: Text('Analyzing board...'),
              duration: Duration(seconds: 2)),
        );
      }

      // Analyze with Gemini
      final analysis = await _geminiService.analyzeBoardImage(
        session.id,
        croppedFile.path,
      );

      if (!mounted) return;

      // Close any existing snackbars
      ScaffoldMessenger.of(context).hideCurrentSnackBar();

      if (analysis['status'] == 'success') {
        List<Map<String, dynamic>> tiles = [];
        String word = '';
        int score = 0;
        String? imagePath = analysis['imagePath'];

        print('Analysis response: $analysis'); // Debug log

        if (analysis['type'] == 'initial') {
          tiles = (analysis['data']['board'] as List)
              .map((tile) => {
                    'letter': tile['letter'],
                    'row': tile['row'],
                    'col': tile['col'],
                    'points': tile['points'],
                  })
              .toList();

          word = tiles.map((t) => t['letter']).join();
          score = tiles.fold(0, (sum, tile) => sum + (tile['points'] as int));

          await gameState.updateBoardState(session.id, tiles);
        } else {
          tiles = (analysis['data']['newLetters'] as List)
              .map((tile) => {
                    'letter': tile['letter'],
                    'row': tile['row'],
                    'col': tile['col'],
                    'points': tile['points'],
                  })
              .toList();

          word = analysis['data']['word'] as String;
          score = analysis['data']['score'] as int;
        }

        // Show confirmation dialog
        final confirmed = await _showMoveConfirmation(context, word, score, tiles);

        if (confirmed == true && mounted) {
          // Add move to session
          await gameState.addMove(
            word: word,
            score: score,
            playerId: session.currentPlayerId,
            tiles: tiles,
            imagePath: imagePath,
          );

          if (mounted) {
            Navigator.pop(context);
          }
        }
      } else {
        throw Exception(analysis['message']);
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error: $e'),
            backgroundColor: Colors.red,
          ),
        );
      }
    } finally {
      if (mounted) {
        setState(() => _processing = false);
      }
    }
  }

  Future<bool?> _showMoveConfirmation(
    BuildContext context,
    String word,
    int score,
    List<Map<String, dynamic>> tiles,
  ) {
    final originalTiles = List<Map<String, dynamic>>.from(tiles);
    List<Map<String, dynamic>> editableTiles = List.from(tiles);
    bool hasBeenEdited = false;

    // Determine word orientation from tiles
    bool isHorizontal = tiles.length > 1
        ? tiles[0]['row'] == tiles[1]['row']
        : true; // Default to horizontal for single letter

    return showDialog<bool>(
      context: context,
      barrierDismissible: false,
      builder: (BuildContext context) {
        return StatefulBuilder(
          builder: (context, setState) {
            return AlertDialog(
              title: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text('Confirm Move: $word'),
                  Text(
                    'Score: $score points',
                    style: const TextStyle(fontSize: 14, color: Colors.grey),
                  ),
                ],
              ),
              content: SingleChildScrollView(
                child: Column(
                  mainAxisSize: MainAxisSize.min,
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    // Starting position editor
                    Row(
                      children: [
                        Expanded(
                          child: TextFormField(
                            initialValue: tiles.first['row'].toString(),
                            decoration: const InputDecoration(
                              labelText: 'Starting Row',
                              helperText: 'Range: 0-14',
                            ),
                            keyboardType: TextInputType.number,
                            onChanged: (value) {
                              final newRow = int.tryParse(value);
                              if (newRow != null &&
                                  newRow >= 0 &&
                                  newRow < 15) {
                                setState(() {
                                  hasBeenEdited = true;
                                  _recalculatePositions(
                                    editableTiles,
                                    startRow: newRow,
                                    startCol: editableTiles.first['col'],
                                    isHorizontal: isHorizontal,
                                  );
                                });
                              }
                            },
                          ),
                        ),
                        const SizedBox(width: 8),
                        Expanded(
                          child: TextFormField(
                            initialValue: tiles.first['col'].toString(),
                            decoration: const InputDecoration(
                              labelText: 'Starting Column',
                              helperText: 'Range: 0-14',
                            ),
                            keyboardType: TextInputType.number,
                            onChanged: (value) {
                              final newCol = int.tryParse(value);
                              if (newCol != null &&
                                  newCol >= 0 &&
                                  newCol < 15) {
                                setState(() {
                                  hasBeenEdited = true;
                                  _recalculatePositions(
                                    editableTiles,
                                    startRow: editableTiles.first['row'],
                                    startCol: newCol,
                                    isHorizontal: isHorizontal,
                                  );
                                });
                              }
                            },
                          ),
                        ),
                      ],
                    ),
                    const SizedBox(height: 16),

                    // Orientation toggle
                    Row(
                      children: [
                        const Text('Orientation:'),
                        const SizedBox(width: 16),
                        ToggleButtons(
                          isSelected: [isHorizontal, !isHorizontal],
                          onPressed: (index) {
                            final newIsHorizontal = index == 0;
                            if (newIsHorizontal != isHorizontal) {
                              setState(() {
                                isHorizontal = newIsHorizontal;
                                hasBeenEdited = true;
                                _recalculatePositions(
                                  editableTiles,
                                  startRow: editableTiles.first['row'],
                                  startCol: editableTiles.first['col'],
                                  isHorizontal: newIsHorizontal,
                                );
                              });
                            }
                          },
                          children: const [
                            Padding(
                              padding: EdgeInsets.symmetric(horizontal: 12),
                              child: Text('Horizontal'),
                            ),
                            Padding(
                              padding: EdgeInsets.symmetric(horizontal: 12),
                              child: Text('Vertical'),
                            ),
                          ],
                        ),
                      ],
                    ),
                    const SizedBox(height: 16),

                    // Preview of tiles
                    const Text(
                      'Tile Positions:',
                      style: TextStyle(fontWeight: FontWeight.bold),
                    ),
                    const SizedBox(height: 8),
                    ...editableTiles.asMap().entries.map((entry) {
                      final index = entry.key;
                      final tile = entry.value;
                      return Padding(
                        padding: const EdgeInsets.only(bottom: 4),
                        child: Text(
                          '${tile['letter']}: Row ${tile['row']}, Col ${tile['col']}',
                          style: const TextStyle(fontFamily: 'monospace'),
                        ),
                      );
                    }),

                    if (hasBeenEdited) ...[
                      const SizedBox(height: 16),
                      const Text(
                        'Manual corrections have been made',
                        style: TextStyle(
                          fontSize: 12,
                          color: Colors.orange,
                          fontStyle: FontStyle.italic,
                        ),
                      ),
                    ],
                  ],
                ),
              ),
              actions: [
                TextButton(
                  onPressed: () => Navigator.pop(context, false),
                  child: const Text('Retake'),
                ),
                TextButton(
                  onPressed: () async {
                    if (hasBeenEdited) {
                      // Save recognition metrics if needed
                    }
                    Navigator.pop(context, true);
                  },
                  style: TextButton.styleFrom(
                    foregroundColor: Colors.green,
                  ),
                  child: const Text('Confirm'),
                ),
              ],
            );
          },
        );
      },
    );
  }

  void _recalculatePositions(
    List<Map<String, dynamic>> tiles, {
    required int startRow,
    required int startCol,
    required bool isHorizontal,
  }) {
    for (int i = 0; i < tiles.length; i++) {
      if (isHorizontal) {
        tiles[i]['row'] = startRow;
        tiles[i]['col'] = startCol + i;
      } else {
        tiles[i]['row'] = startRow + i;
        tiles[i]['col'] = startCol;
      }
    }
  }

  Future<void> _showTileEditor(
    BuildContext context,
    Map<String, dynamic> tile,
    Function(Map<String, dynamic>) onUpdate,
  ) {
    final letterController = TextEditingController(text: tile['letter']);
    final pointsController =
        TextEditingController(text: tile['points'].toString());
    final rowController = TextEditingController(text: tile['row'].toString());
    final colController = TextEditingController(text: tile['col'].toString());

    return showDialog<void>(
      context: context,
      builder: (BuildContext context) {
        return AlertDialog(
          title: const Text('Edit Tile'),
          content: SingleChildScrollView(
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                TextField(
                  controller: letterController,
                  decoration: const InputDecoration(labelText: 'Letter'),
                  textCapitalization: TextCapitalization.characters,
                  maxLength: 1,
                ),
                TextField(
                  controller: pointsController,
                  decoration: const InputDecoration(labelText: 'Points'),
                  keyboardType: TextInputType.number,
                ),
                TextField(
                  controller: rowController,
                  decoration: const InputDecoration(
                    labelText: 'Row',
                    helperText: 'Valid range: 0-14',
                  ),
                  keyboardType: TextInputType.number,
                ),
                TextField(
                  controller: colController,
                  decoration: const InputDecoration(
                    labelText: 'Column',
                    helperText: 'Valid range: 0-14',
                  ),
                  keyboardType: TextInputType.number,
                ),
              ],
            ),
          ),
          actions: [
            TextButton(
              onPressed: () => Navigator.pop(context),
              child: const Text('Cancel'),
            ),
            TextButton(
              onPressed: () {
                // Validate input
                final row = int.tryParse(rowController.text);
                final col = int.tryParse(colController.text);
                final points = int.tryParse(pointsController.text);

                if (letterController.text.isEmpty ||
                    row == null ||
                    row < 0 ||
                    row > 14 ||
                    col == null ||
                    col < 0 ||
                    col > 14 ||
                    points == null) {
                  ScaffoldMessenger.of(context).showSnackBar(
                    const SnackBar(
                      content: Text('Please enter valid values'),
                      backgroundColor: Colors.red,
                    ),
                  );
                  return;
                }

                onUpdate({
                  'letter': letterController.text.toUpperCase(),
                  'points': points,
                  'row': row,
                  'col': col,
                });
                Navigator.pop(context);
              },
              child: const Text('Save'),
            ),
          ],
        );
      },
    );
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Capture Move'),
      ),
      body: _buildBody(),
    );
  }

  Widget _buildBody() {
    if (_error != null) {
      return Center(
        child: Padding(
          padding: const EdgeInsets.all(16.0),
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              Text(
                _error!,
                textAlign: TextAlign.center,
                style: const TextStyle(color: Colors.red),
              ),
              const SizedBox(height: 16),
              ElevatedButton(
                onPressed: _requestCameraPermission,
                child: const Text('Grant Camera Permission'),
              ),
              const SizedBox(height: 8),
              TextButton(
                onPressed: () => openAppSettings(),
                child: const Text('Open App Settings'),
              ),
            ],
          ),
        ),
      );
    }

    if (!_isCameraInitialized || _controller == null) {
      return const Center(child: CircularProgressIndicator());
    }
    return Stack(
      fit: StackFit.expand,
      children: [
        // Camera Preview
        CameraPreview(_controller!),

        // Board Alignment Overlay
        CustomPaint(
          painter: BoardOverlayPainter(),
          child: Container(),
        ),

        // Processing Indicator
        if (_processing)
          Container(
            color: Colors.black54,
            child: const Center(
              child: CircularProgressIndicator(color: Colors.white),
            ),
          ),

        // Capture Button
        Positioned(
          bottom: 32,
          left: 0,
          right: 0,
          child: Center(
            child: FloatingActionButton(
              onPressed: _processing ? null : _captureAndAnalyze,
              child: _processing
                  ? const SizedBox(
                      width: 24,
                      height: 24,
                      child: CircularProgressIndicator(
                        color: Colors.white,
                        strokeWidth: 2,
                      ),
                    )
                  : const Icon(Icons.camera_alt),
            ),
          ),
        ),

        // Instructions (moved up to avoid button overlap)
        Positioned(
          bottom: 100, // Increased bottom padding to move above the button
          left: 0,
          right: 0,
          child: Container(
            color: Colors.black54,
            padding: const EdgeInsets.symmetric(vertical: 12, horizontal: 16),
            child: const Text(
              'Align the board within the square frame and ensure good lighting',
              style: TextStyle(
                color: Colors.white,
                fontSize: 14,
              ),
              textAlign: TextAlign.center,
            ),
          ),
        ),
      ],
    );
  }
}
```\n
\n### src/screens/game_setup_screen.dart\n
```dart
// lib/src/screens/game_setup_screen.dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../providers/game_session_provider.dart';
import 'game_monitoring_screen.dart';

class GameSetupScreen extends StatefulWidget {
  const GameSetupScreen({super.key});

  @override
  State<GameSetupScreen> createState() => _GameSetupScreenState();
}

class _GameSetupScreenState extends State<GameSetupScreen> {
  final _formKey = GlobalKey<FormState>();
  final _player1Controller = TextEditingController();
  final _player2Controller = TextEditingController();
  bool _isProcessing = false;

  @override
  void dispose() {
    _player1Controller.dispose();
    _player2Controller.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('New Game Setup'),
      ),
      body: Padding(
        padding: const EdgeInsets.all(16),
        child: Form(
          key: _formKey,
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.stretch,
            children: [
              TextFormField(
                controller: _player1Controller,
                decoration: const InputDecoration(
                  labelText: 'Player 1 Name',
                  prefixIcon: Icon(Icons.person),
                ),
                validator: (value) {
                  if (value == null || value.trim().isEmpty) {
                    return 'Please enter player 1 name';
                  }
                  return null;
                },
              ),
              const SizedBox(height: 16),
              TextFormField(
                controller: _player2Controller,
                decoration: const InputDecoration(
                  labelText: 'Player 2 Name',
                  prefixIcon: Icon(Icons.person),
                ),
                validator: (value) {
                  if (value == null || value.trim().isEmpty) {
                    return 'Please enter player 2 name';
                  }
                  return null;
                },
              ),
              const SizedBox(height: 32),
              ElevatedButton(
                onPressed: _isProcessing ? null : _startGame,
                style: ElevatedButton.styleFrom(
                  padding: const EdgeInsets.symmetric(vertical: 16),
                ),
                child: _isProcessing
                    ? const CircularProgressIndicator()
                    : const Text('Start Game'),
              ),
              if (context.select((GameSessionProvider p) => p.error) != null)
                Padding(
                  padding: const EdgeInsets.only(top: 16),
                  child: Text(
                    context.read<GameSessionProvider>().error!,
                    style: const TextStyle(color: Colors.red),
                  ),
                ),
            ],
          ),
        ),
      ),
    );
  }

  Future<void> _startGame() async {
    if (!_formKey.currentState!.validate()) return;

    setState(() => _isProcessing = true);

    try {
      await context.read<GameSessionProvider>().createGameSession(
            _player1Controller.text.trim(),
            _player2Controller.text.trim(),
          );

      if (!mounted) return;
      String sessionId = context.read<GameSessionProvider>().currentSession!.id;
      // Navigate to monitoring screen
      Navigator.of(context).pushReplacement(
        MaterialPageRoute(
          builder: (_) =>  GameMonitoringScreen(sessionId: sessionId),
        ),
      );
    } finally {
      if (mounted) {
        setState(() => _isProcessing = false);
      }
    }
  }
}
```\n
\n### src/themes/app_theme.dart\n
```dart
import 'package:flutter/material.dart';

class AppTheme {
  static ThemeData get theme => ThemeData(
    // Theme configuration will go here
  );
}
```\n
\n### src/services/recognition_metrics_service.dart\n
```dart
// lib/src/services/recognition_metrics_service.dart
import 'package:cloud_firestore/cloud_firestore.dart';

class RecognitionMetrics {
  final String sessionId;
  final String moveId;
  final int totalTiles;
  final int correctedTiles;
  final Map<String, dynamic> originalValues;
  final Map<String, dynamic> correctedValues;
  final DateTime timestamp;

  RecognitionMetrics({
    required this.sessionId,
    required this.moveId,
    required this.totalTiles,
    required this.correctedTiles,
    required this.originalValues,
    required this.correctedValues,
    required this.timestamp,
  });

  Map<String, dynamic> toJson() => {
    'sessionId': sessionId,
    'moveId': moveId,
    'totalTiles': totalTiles,
    'correctedTiles': correctedTiles,
    'accuracyRate': (totalTiles - correctedTiles) / totalTiles,
    'originalValues': originalValues,
    'correctedValues': correctedValues,
    'timestamp': Timestamp.fromDate(timestamp),
  };
}

class RecognitionMetricsService {
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;

  Future<void> saveMetrics(RecognitionMetrics metrics) async {
    try {
      // Store in a subcollection under the game session
      await _firestore
          .collection('game_sessions')
          .doc(metrics.sessionId)
          .collection('recognition_metrics')
          .add(metrics.toJson());
      
      // Also store in a global metrics collection for easier analysis
      await _firestore
          .collection('recognition_metrics')
          .add(metrics.toJson());
    } catch (e) {
      print('Error saving recognition metrics: $e');
      rethrow;
    }
  }

  // Get metrics for a specific session
  Future<List<RecognitionMetrics>> getSessionMetrics(String sessionId) async {
    try {
      final snapshot = await _firestore
          .collection('game_sessions')
          .doc(sessionId)
          .collection('recognition_metrics')
          .orderBy('timestamp', descending: true)
          .get();

      return snapshot.docs.map((doc) {
        final data = doc.data();
        return RecognitionMetrics(
          sessionId: data['sessionId'],
          moveId: data['moveId'],
          totalTiles: data['totalTiles'],
          correctedTiles: data['correctedTiles'],
          originalValues: data['originalValues'],
          correctedValues: data['correctedValues'],
          timestamp: (data['timestamp'] as Timestamp).toDate(),
        );
      }).toList();
    } catch (e) {
      print('Error getting session metrics: $e');
      rethrow;
    }
  }

  // Get overall accuracy statistics
  Future<Map<String, dynamic>> getOverallStats() async {
    try {
      final snapshot = await _firestore
          .collection('recognition_metrics')
          .get();

      final metrics = snapshot.docs.map((doc) => doc.data()).toList();
      
      final totalMoves = metrics.length;
      final totalAccuracy = metrics.fold<double>(
        0,
        (sum, metric) => sum + metric['accuracyRate'],
      );

      return {
        'totalMoves': totalMoves,
        'averageAccuracy': totalMoves > 0 ? totalAccuracy / totalMoves : 0,
        'lastUpdated': DateTime.now(),
      };
    } catch (e) {
      print('Error getting overall stats: $e');
      rethrow;
    }
  }
}```\n
\n### src/services/firebase_service.dart\n
```dart
// lib/src/services/firebase_service.dart
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:uuid/uuid.dart';
import '../models/game_session.dart';

class FirebaseService {
  final FirebaseFirestore _firestore = FirebaseFirestore.instanceFor(
    app: FirebaseFirestore.instance.app,
    databaseId: "scrabble",
  );
  final _uuid = const Uuid();

  // Update session QR code
  Future<GameSession> updateSessionQRCode(
    String sessionId,
    String qrCode,
  ) async {
    await _firestore
        .collection('game_sessions')
        .doc(sessionId)
        .update({'qrCode': qrCode});

    final doc =
        await _firestore.collection('game_sessions').doc(sessionId).get();

    return _parseSessionDoc(doc);
  }

  // Update session status
  Future<void> updateSessionStatus(
    String sessionId,
    bool isActive,
  ) async {
    await _firestore
        .collection('game_sessions')
        .doc(sessionId)
        .update({'isActive': isActive});
  }

  // Get session by ID
  Future<GameSession> getSession(String sessionId) async {
    final doc =
        await _firestore.collection('game_sessions').doc(sessionId).get();

    if (!doc.exists) {
      throw Exception('Session not found');
    }

    return _parseSessionDoc(doc);
  }

  // Get active sessions
  Stream<List<GameSession>> getActiveSessions() {
    return _firestore
        .collection('game_sessions')
        .where('isActive', isEqualTo: true)
        .orderBy('startTime', descending: true)
        .snapshots()
        .map((snapshot) {
      return snapshot.docs.map((doc) => _parseSessionDoc(doc)).toList();
    });
  }

// Get real-time board state updates
  Stream<Map<String, dynamic>> getBoardState(String sessionId) {
    return _firestore
        .collection('game_sessions')
        .doc(sessionId)
        .collection('board_state')
        .doc('current')
        .snapshots()
        .map((snapshot) {
      if (!snapshot.exists) {
        return {};
      }
      return snapshot.data() as Map<String, dynamic>;
    });
  }

  // Get real-time session moves
  Stream<List<Map<String, dynamic>>> getSessionMoves(String sessionId) {
    return _firestore
        .collection('game_sessions')
        .doc(sessionId)
        .collection('moves')
        .orderBy('timestamp', descending: false)
        .snapshots()
        .map((snapshot) {
      return snapshot.docs.map((doc) {
        final data = doc.data();
        // Convert Timestamp to DateTime
        if (data['timestamp'] is Timestamp) {
          data['timestamp'] = (data['timestamp'] as Timestamp).toDate();
        }
        return data;
      }).toList();
    });
  }

  // Get real-time player score
  Stream<int> getPlayerScore(String sessionId, String playerId) {
    return _firestore
        .collection('game_sessions')
        .doc(sessionId)
        .collection('moves')
        .where('playerId', isEqualTo: playerId)
        .snapshots()
        .map((snapshot) {
      return snapshot.docs.fold<int>(
        0,
        (sum, doc) => sum + (doc.data()['score'] as int? ?? 0),
      );
    });
  }

  // Update player score (if needed separately from moves)
  Future<void> updatePlayerScore(
      String sessionId, String playerId, int score) async {
    await _firestore.collection('game_sessions').doc(sessionId).update({
      'scores.$playerId': FieldValue.increment(score),
    });
  }

  // Get single move by ID
  Future<Map<String, dynamic>?> getMove(String sessionId, String moveId) async {
    final doc = await _firestore
        .collection('game_sessions')
        .doc(sessionId)
        .collection('moves')
        .doc(moveId)
        .get();

    if (!doc.exists) return null;

    final data = doc.data()!;
    if (data['timestamp'] is Timestamp) {
      data['timestamp'] = (data['timestamp'] as Timestamp).toDate();
    }
    return data;
  }

  // Switch to next player's turn
  Future<void> switchTurn(String sessionId) async {
    final session = await getSession(sessionId);
    final nextPlayerId = session.getNextPlayerId();

    await _firestore
        .collection('game_sessions')
        .doc(sessionId)
        .update({'currentPlayerId': nextPlayerId});
  }

  // Update your createGameSession method to include currentPlayerId
  Future<GameSession> createGameSession({
    required String player1Name,
    required String player2Name,
  }) async {
    final sessionId = _uuid.v4();
    final sessionData = {
      'id': sessionId,
      'player1Name': player1Name,
      'player2Name': player2Name,
      'startTime': FieldValue.serverTimestamp(),
      'isActive': true,
      'currentPlayerId': 'p1', // Start with player 1
      'createdAt': FieldValue.serverTimestamp(),
    };

    await _firestore
        .collection('game_sessions')
        .doc(sessionId)
        .set(sessionData);

    return GameSession(
      id: sessionId,
      player1Name: player1Name,
      player2Name: player2Name,
      startTime: DateTime.now(),
      currentPlayerId: 'p1',
      isActive: true,
    );
  }

  Future<String?> getLastMoveImage(String sessionId) async {
    try {
      final querySnapshot = await _firestore
          .collection('game_sessions')
          .doc(sessionId)
          .collection('moves')
          .orderBy('timestamp', descending: true)
          .limit(1)
          .get();

      if (querySnapshot.docs.isEmpty) {
        return null;
      }

      final moveData = querySnapshot.docs.first.data();
      return moveData['imagePath'] as String?;
    } catch (e) {
      print('Error getting last move image: $e');
      return null;
    }
  }

  // Update the addMoveToSession method to include the image path
  Future<void> addMoveToSession({
    required String sessionId,
    required String word,
    required int score,
    required String playerId,
    required List<Map<String, dynamic>> tiles,
    String? imagePath, // Add this parameter
  }) async {
    final batch = _firestore.batch();

    // Add the move
    final moveRef = _firestore
        .collection('game_sessions')
        .doc(sessionId)
        .collection('moves')
        .doc();

    batch.set(moveRef, {
      'word': word,
      'score': score,
      'playerId': playerId,
      'tiles': tiles,
      'timestamp': FieldValue.serverTimestamp(),
      'imagePath': imagePath, // Store the image path
    });

    // Switch to next player
    final sessionRef = _firestore.collection('game_sessions').doc(sessionId);
    final session = await getSession(sessionId);

    batch.update(sessionRef, {
      'currentPlayerId': session.getNextPlayerId(),
      'lastMoveImage': imagePath, // Also store in session for quick access
    });

    await batch.commit();
  }

  Stream<QuerySnapshot> getGameSessions() {
    return _firestore
        .collection('game_sessions')
        .orderBy('startTime', descending: true)
        .snapshots();
  }

  // Delete a session and all its subcollections
  Future<void> deleteSession(String sessionId) async {
    // Delete moves subcollection
    final movesSnapshot = await _firestore
        .collection('game_sessions')
        .doc(sessionId)
        .collection('moves')
        .get();

    final batch = _firestore.batch();

    for (var doc in movesSnapshot.docs) {
      batch.delete(doc.reference);
    }

    // Delete main session document
    batch.delete(_firestore.collection('game_sessions').doc(sessionId));

    await batch.commit();
  }

  // Get remaining letters
  Future<int> getRemainingLetters(String sessionId) async {
    final doc = await _firestore
        .collection('game_sessions')
        .doc(sessionId)
        .collection('game_state')
        .doc('letters')
        .get();

    if (!doc.exists) {
      return 0;
    }

    final data = doc.data() as Map<String, dynamic>;
    return data['remaining'] ?? 0;
  }

  // Update the board state with new tiles
  Future<void> updateBoardState(
      String sessionId, List<Map<String, dynamic>> tiles) async {
    final batch = _firestore.batch();
    final boardRef = _firestore
        .collection('game_sessions')
        .doc(sessionId)
        .collection('board_state')
        .doc('current');

    // Get current board state
    final currentState = await boardRef.get();
    Map<String, dynamic> currentData = currentState.data() ?? {};

    // Update with new tiles
    for (var tile in tiles) {
      String key = '${tile['row']}-${tile['col']}';
      currentData[key] = {
        'letter': tile['letter'],
        'points': tile['points'],
        'playerId': tile['playerId'],
      };
    }

    batch.set(boardRef, currentData, SetOptions(merge: true));
    await batch.commit();
  }

// Update the session with the last move's image path
  Future<void> updateSessionImage(String sessionId, String imagePath) async {
    await _firestore.collection('game_sessions').doc(sessionId).update({
      'lastMoveImage': imagePath,
    });
  }

  GameSession _parseSessionDoc(DocumentSnapshot doc) {
    final data = doc.data() as Map<String, dynamic>;
    final timestamp = data['startTime'] as Timestamp;

    // Get moves from the document if they exist
    List<Move> moves = [];
    if (data['moves'] != null) {
      moves = (data['moves'] as List)
          .map((moveData) => Move.fromJson(moveData))
          .toList();
    }

    return GameSession(
      id: doc.id,
      player1Name: data['player1Name'],
      player2Name: data['player2Name'],
      startTime: timestamp.toDate(),
      qrCode: data['qrCode'],
      isActive: data['isActive'] ?? false,
      currentPlayerId: data['currentPlayerId'] ?? 'p1',
      moves: moves,
    );
  }

  Future<Move?> getLastMove(String sessionId) async {
    try {
      final querySnapshot = await _firestore
          .collection('game_sessions')
          .doc(sessionId)
          .collection('moves')
          .orderBy('timestamp', descending: true)
          .limit(1)
          .get();

      if (querySnapshot.docs.isEmpty) {
        return null;
      }

      return Move.fromJson(querySnapshot.docs.first.data());
    } catch (e) {
      print('Error getting last move: $e');
      return null;
    }
  }

  Future<void> switchCurrentPlayer(String sessionId, String playerId) async {
    await _firestore
        .collection('game_sessions')
        .doc(sessionId)
        .update({'currentPlayerId': playerId});
  }

    Future<int> getMoveCount(String sessionId) async {
    final movesSnapshot = await _firestore
        .collection('game_sessions')
        .doc(sessionId)
        .collection('moves')
        .count()
        .get();
    
    return movesSnapshot.count ?? 0;
  }
}
```\n
\n### src/services/board_validator.dart\n
```dart
// lib/src/services/board_validator.dart
import '../models/board_square.dart';

class ValidationResult {
  final bool isValid;
  final String? error;
  final bool connectsToExisting;
  final List<String> formedWords;

  ValidationResult({
    required this.isValid,
    this.error,
    required this.connectsToExisting,
    this.formedWords = const [],
  });
}

class BoardValidator {
  static ValidationResult validateMove({
    required List<Map<String, dynamic>> newTiles,
    required List<List<BoardSquare>> currentBoard,
    required bool isFirstMove,
  }) {
    // Check if tiles are within board bounds
    for (var tile in newTiles) {
      if (tile['row'] < 0 ||
          tile['row'] >= 15 ||
          tile['col'] < 0 ||
          tile['col'] >= 15) {
        return ValidationResult(
          isValid: false,
          error: 'Word placement extends beyond board boundaries',
          connectsToExisting: false,
        );
      }
    }

    // Check if first move uses center square
    if (isFirstMove) {
      bool usesCenterSquare =
          newTiles.any((tile) => tile['row'] == 7 && tile['col'] == 7);
      if (!isFirstMove) {
        return ValidationResult(
          isValid: false,
          error: 'First move must use the center square',
          connectsToExisting: false,
        );
      }
    }

    // Check for tile conflicts and connections
    bool connectsToExisting = false;
    List<String> formedWords = [];

    for (var tile in newTiles) {
      final row = tile['row'] as int;
      final col = tile['col'] as int;

      // Check for conflicts with existing tiles
      if (currentBoard[row][col].tile != null) {
        if (currentBoard[row][col].tile!['letter'] != tile['letter']) {
          return ValidationResult(
            isValid: false,
            error: 'Conflict with existing tile at row $row, col $col',
            connectsToExisting: false,
          );
        }
      }

      // Check for adjacent tiles (if not first move)
      if (!isFirstMove) {
        final directions = [(-1, 0), (1, 0), (0, -1), (0, 1)];
        for (var (dRow, dCol) in directions) {
          final newRow = row + dRow;
          final newCol = col + dCol;

          if (newRow >= 0 && newRow < 15 && newCol >= 0 && newCol < 15) {
            if (currentBoard[newRow][newCol].tile != null) {
              connectsToExisting = true;
              // Could collect formed words here
              break;
            }
          }
        }
      }
    }

    // After first move, must connect to existing tiles
    if (!isFirstMove && !connectsToExisting) {
      return ValidationResult(
        isValid: false,
        error: 'New word must connect to existing tiles',
        connectsToExisting: false,
      );
    }

    return ValidationResult(
      isValid: true,
      connectsToExisting: connectsToExisting,
      formedWords: formedWords,
    );
  }
}
```\n
\n### src/services/gemini_service.dart\n
```dart
import 'dart:convert';
import 'dart:io';
import 'package:firebase_storage/firebase_storage.dart';
import 'package:firebase_vertexai/firebase_vertexai.dart';
import '../services/firebase_service.dart';

class GeminiService {
  late GenerativeModel _model;
  final FirebaseService _firebaseService = FirebaseService();
  final FirebaseStorage _storage = FirebaseStorage.instance;

  GeminiService() {
    _model =
        FirebaseVertexAI.instance.generativeModel(model: 'gemini-2.0-flash-exp');
  }

  Future<String> _uploadImageToStorage(
      String sessionId, String imagePath, int moveNumber) async {
    try {
      final File imageFile = File(imagePath);
      if (!await imageFile.exists()) {
        throw Exception('Image file not found at $imagePath');
      }

      final fileName = 'moves/${sessionId}/${moveNumber}.jpg';
      final ref = _storage.ref().child(fileName);

      // Create upload task
      final uploadTask = ref.putFile(
        imageFile,
        SettableMetadata(
          contentType: 'image/jpeg',
          customMetadata: {
            'sessionId': sessionId,
            'moveNumber': moveNumber.toString(),
          },
        ),
      );

      // Monitor upload progress
      uploadTask.snapshotEvents.listen((TaskSnapshot snapshot) {
        print(
            'Upload progress: ${snapshot.bytesTransferred}/${snapshot.totalBytes}');
      });

      // Wait for upload to complete
      await uploadTask;

      print('Image uploaded successfully to $fileName');
      return fileName;
    } catch (e) {
      print('Error uploading image: $e');
      throw Exception('Failed to upload image: $e');
    }
  }

  Future<Map<String, dynamic>> analyzeBoardImage(
    String sessionId,
    String imagePath,
  ) async {
    try {
      // Get current move number based on existing moves
      final moveCount = await _firebaseService.getMoveCount(sessionId);
      final currentMoveNumber = moveCount + 1;

      // Get previous board state
      final boardState = await _firebaseService.getBoardState(sessionId).first;
      final isFirstMove = boardState.isEmpty;

      // Upload current image with sequential naming
      final currentImagePath = await _uploadImageToStorage(
        sessionId,
        imagePath,
        currentMoveNumber,
      );

      // Read current image bytes
      final currentImageBytes = await File(imagePath).readAsBytes();

      if (isFirstMove) {
        // Handle first move
        final response = await _model.generateContent([
          Content.multi([
            TextPart(_constructInitialBoardPrompt()),
            DataPart('image/jpeg', currentImageBytes),
          ]),
        ]);

        if (response.text == null) {
          throw Exception('Empty response from Gemini');
        }

        return {
          'status': 'success',
          'type': 'initial',
          'data': _parseGeminiResponse(response.text!, true),
          'imagePath': currentImagePath,
          'moveNumber': currentMoveNumber,
        };
      } else {
        // Get previous image
        final previousMoveNumber = currentMoveNumber - 1;
        final previousImageRef =
            _storage.ref().child('moves/$sessionId/$previousMoveNumber.jpg');

        final prevImageBytes = await previousImageRef.getData();
        if (prevImageBytes == null) {
          throw Exception('Previous move image not found');
        }

        // Compare images using Gemini
        final response = await _model.generateContent([
          Content.multi([
            TextPart(_constructImageComparisonPrompt(boardState)),
            DataPart('image/jpeg', prevImageBytes),
            DataPart('image/jpeg', currentImageBytes),
          ]),
        ]);

        if (response.text == null) {
          throw Exception('Empty response from Gemini');
        }

        return {
          'status': 'success',
          'type': 'move',
          'data': _parseGeminiResponse(response.text!, false),
          'imagePath': currentImagePath,
          'moveNumber': currentMoveNumber,
        };
      }
    } catch (e) {
      print('Error in analyzeBoardImage: $e');
      return {
        'status': 'error',
        'message': e.toString(),
      };
    }
  }

  String _constructInitialBoardPrompt() {
    return '''
You are analyzing an image of an initial Scrabble board move. The image is clear and well-lit. 
Accurately identify all visible letters and their precise positions on the board, using the center star 
as a reference point. It is crucial that the letter positions are identified correctly.
Determine the word played and its score, including any applicable board multipliers.

Return ONLY a JSON object in exactly this format:
{
  "board": [
    {
      "letter": "A",
      "row": 7,
      "col": 7,
      "points": 1
    }
  ]
}

Rules:

- Use 0-based indices (0-14) for rows and columns
- Include ONLY placed letters, ignore empty squares
- All coordinates must be within the 15x15 grid
- Return ONLY the JSON, no explanatory text
''';
  }

  String _constructImageComparisonPrompt(Map<String, dynamic> previousState) {
    return '''
Compare these two Scrabble board images: the first is the previous state before a move, the second is the current state after a move.
Identify ONLY the letters that appear in the second image but not in the first.

Determine the word played and its score, including any applicable board multipliers.

Previous board state for reference:
${jsonEncode(previousState)}

Return ONLY a JSON object in exactly this format:
{
  "word": "EXAMPLE",
  "score": 15,
  "newLetters": [
    {
      "letter": "A",
      "row": 7,
      "col": 7,
      "points": 1
    }
  ]
}

Rules:
- Calculate score including board multipliers
- Calculate the score based on the tile values and any board multipliers active during the play. Do not include the 50-point bonus for using all 7 tiles.
- Return ONLY the JSON, no explanatory text
- Use 0-based indices (0-14) for coordinates
- All coordinates must be within the 15x15 grid
- If no valid word was played (e.g., the board states are identical), return: {"word": "", "score": 0, "newLetters": []}
''';
  }

  Map<String, dynamic> _parseGeminiResponse(String response, bool isFirstMove) {
    try {
      String cleanJson = response
          .replaceAll(RegExp(r'```json\n?'), '')
          .replaceAll(RegExp(r'```\n?'), '')
          .trim();

      return jsonDecode(cleanJson);
    } catch (e) {
      throw Exception('Invalid response format: $e');
    }
  }
}
```\n
\n### src/services/score_calculator.dart\n
```dart
// lib/src/services/score_calculator.dart
import '../models/board_square.dart';

class ScoreCalculator {
  // French Scrabble letter points
  static const Map<String, int> letterPoints = {
    'A': 1, 'B': 3, 'C': 3, 'D': 2, 'E': 1,
    'F': 4, 'G': 2, 'H': 4, 'I': 1, 'J': 8,
    'K': 10, 'L': 1, 'M': 2, 'N': 1, 'O': 1,
    'P': 3, 'Q': 8, 'R': 1, 'S': 1, 'T': 1,
    'U': 1, 'V': 4, 'W': 10, 'X': 10, 'Y': 10,
    'Z': 10, '*': 0, // Blank tiles worth 0 points
  };

  static SquareType getSquareType(int row, int col) {
    // Center square
    if (row == 7 && col == 7) {
      return SquareType.doubleWord;
    }

    // Triple Word Score
    if ((row == 0 || row == 14) && (col == 0 || col == 7 || col == 14) ||
        (row == 7 && (col == 0 || col == 14))) {
      return SquareType.tripleWord;
    }

    // Double Word Score
    if (row == col || row + col == 14) {
      if (row >= 1 && row <= 5 || row >= 9 && row <= 13) {
        return SquareType.doubleWord;
      }
    }

    // Triple Letter Score
    if ((row == 1 || row == 13) && (col == 5 || col == 9) ||
        (row == 5 || row == 9) &&
            (col == 1 || col == 5 || col == 9 || col == 13)) {
      return SquareType.tripleLetter;
    }

    // Double Letter Score
    if ((row == 3 || row == 11) && (col == 0 || col == 7 || col == 14) ||
        (row == 6 || row == 8) && (col == 2 || col == 6 || col == 8 || col == 12) ||
        (row == 0 || row == 7 || col == 14) && (col == 3 || col == 11)) {
      return SquareType.doubleLetter;
    }

    return SquareType.normal;
  }

  static int calculateScore(List<Map<String, dynamic>> tiles, {bool isFirstMove = false}) {
    int wordScore = 0;
    int wordMultiplier = 1;
    bool usedCenter = false;

    // Calculate base score with letter multipliers
    for (var tile in tiles) {
      int letterScore = letterPoints[tile['letter']] ?? 0;
      final squareType = getSquareType(tile['row'], tile['col']);

      // Check if using center square
      if (tile['row'] == 7 && tile['col'] == 7) {
        usedCenter = true;
      }

      // Apply letter multipliers
      switch (squareType) {
        case SquareType.doubleLetter:
          letterScore *= 2;
          break;
        case SquareType.tripleLetter:
          letterScore *= 3;
          break;
        case SquareType.doubleWord:
          wordMultiplier *= 2;
          break;
        case SquareType.tripleWord:
          wordMultiplier *= 3;
          break;
        default:
          break;
      }

      wordScore += letterScore;
    }

    // Apply word multiplier
    wordScore *= wordMultiplier;

    // First move must use center square and gets double word score
    if (isFirstMove && usedCenter) {
      wordScore *= 2;
    }

    // Add Scrabble bonus (50 points) if all 7 letters are used
    if (tiles.length == 7) {
      wordScore += 50;
    }

    return wordScore;
  }
}```\n
\n### src/services/qr_service.dart\n
```dart
// lib/src/services/qr_service.dart
import 'dart:convert';
import 'package:qr_flutter/qr_flutter.dart';
import 'package:flutter/material.dart';

class QRService {
  // Generate QR code data
  String generateQRCodeData(String sessionId) {
    final data = {
      'sessionId': sessionId,
      'timestamp': DateTime.now().toIso8601String(),
      'type': 'scrabble_game',
    };
    
    return jsonEncode(data);
  }

  // Generate QR code widget
  Widget generateQRCode(String sessionId, {double size = 200}) {
    final data = generateQRCodeData(sessionId);
    
    return QrImageView(
      data: data,
      version: QrVersions.auto,
      size: size,
      backgroundColor: Colors.white,
    );
  }
}

// lib/src/screens/qr_display_screen.dart
class QRDisplayScreen extends StatelessWidget {
  final String sessionId;
  final QRService _qrService = QRService();

  QRDisplayScreen({
    super.key,
    required this.sessionId,
  });

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Connect to Game'),
      ),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Card(
              elevation: 4,
              child: Padding(
                padding: const EdgeInsets.all(16.0),
                child: Column(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    _qrService.generateQRCode(sessionId, size: 250),
                    const SizedBox(height: 16),
                    const Text(
                      'Scan this code with the Companion App',
                      style: TextStyle(fontSize: 16),
                    ),
                    const SizedBox(height: 8),
                    Text(
                      'Session ID: $sessionId',
                      style: const TextStyle(
                        fontSize: 12,
                        color: Colors.grey,
                      ),
                    ),
                  ],
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }
}```\n
\n### src/widgets/board_preview_widget.dart\n
```dart
// lib/src/widgets/board_preview_widget.dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../providers/game_session_provider.dart';
import '../services/firebase_service.dart';

class BoardPreviewWidget extends StatelessWidget {
  const BoardPreviewWidget({super.key});

  @override
  Widget build(BuildContext context) {
    return Card(
      margin: const EdgeInsets.all(16),
      child: Consumer<GameSessionProvider>(
        builder: (context, provider, child) {
          return StreamBuilder<Map<String, dynamic>>(
            stream: FirebaseService().getBoardState(provider.currentSession!.id),
            builder: (context, snapshot) {
              if (snapshot.hasError) {
                return Center(child: Text('Error: ${snapshot.error}'));
              }

              if (!snapshot.hasData) {
                return const Center(child: CircularProgressIndicator());
              }

              final boardState = snapshot.data!;
              return GridView.builder(
                physics: const NeverScrollableScrollPhysics(),
                gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
                  crossAxisCount: 15,
                  childAspectRatio: 1,
                ),
                itemCount: 225, // 15x15 grid
                itemBuilder: (context, index) {
                  final row = index ~/ 15;
                  final col = index % 15;
                  return _buildSquare(context, boardState, row, col);
                },
              );
            },
          );
        },
      ),
    );
  }

  Widget _buildSquare(BuildContext context, Map<String, dynamic> boardState, int row, int col) {
    final squareData = boardState['$row-$col'] as Map<String, dynamic>?;

    return Container(
      decoration: BoxDecoration(
        border: Border.all(color: Colors.black12),
        color: _getSquareColor(squareData?['type'] ?? 'normal'),
      ),
      child: squareData?['letter'] != null
          ? _buildTile(context, squareData!)
          : _buildSquareContent(squareData?['type'] ?? 'normal'),
    );
  }

  Widget _buildTile(BuildContext context, Map<String, dynamic> tileData) {
    return Container(
      margin: const EdgeInsets.all(1),
      decoration: BoxDecoration(
        color: const Color(0xFFF7D698),
        borderRadius: BorderRadius.circular(4),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.2),
            blurRadius: 2,
            offset: const Offset(1, 1),
          ),
        ],
      ),
      child: Stack(
        children: [
          Center(
            child: Text(
              tileData['letter'],
              style: const TextStyle(
                fontSize: 14,
                fontWeight: FontWeight.bold,
              ),
            ),
          ),
          Positioned(
            right: 2,
            bottom: 1,
            child: Text(
              '${tileData['points']}',
              style: const TextStyle(
                fontSize: 8,
                fontWeight: FontWeight.bold,
                color: Colors.black54,
              ),
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildSquareContent(String type) {
    String label = '';
    switch (type) {
      case 'tripleWord':
        label = 'TW';
        break;
      case 'doubleWord':
        label = 'DW';
        break;
      case 'tripleLetter':
        label = 'TL';
        break;
      case 'doubleLetter':
        label = 'DL';
        break;
      case 'center':
        label = 'â˜…';
        break;
      default:
        return const SizedBox();
    }

    return Center(
      child: Text(
        label,
        style: const TextStyle(
          fontSize: 10,
          fontWeight: FontWeight.bold,
          color: Colors.black54,
        ),
      ),
    );
  }

  Color _getSquareColor(String type) {
    switch (type) {
      case 'tripleWord':
        return Colors.red[100]!;
      case 'doubleWord':
        return Colors.pink[50]!;
      case 'tripleLetter':
        return Colors.blue[100]!;
      case 'doubleLetter':
        return Colors.lightBlue[50]!;
      case 'center':
        return Colors.pink[50]!;
      default:
        return Colors.white;
    }
  }
}```\n
\n### src/widgets/board_overlay_painter.dart\n
```dart
import 'package:flutter/material.dart';

class BoardOverlayPainter extends CustomPainter {
  @override
  void paint(Canvas canvas, Size size) {
    final paint = Paint()
      ..color = Colors.white.withOpacity(0.3)
      ..style = PaintingStyle.stroke
      ..strokeWidth = 2.0;

    // Calculate square size to maintain aspect ratio
    final squareSize = size.width < size.height ? size.width * 0.8 : size.height * 0.8;
    final left = (size.width - squareSize) / 2;
    final top = (size.height - squareSize) / 2;
    final rect = Rect.fromLTWH(left, top, squareSize, squareSize);

    // Draw the main square frame
    canvas.drawRect(rect, paint);

    // Draw corner markers for better alignment
    final cornerLength = squareSize * 0.1;
    final corners = [
      [rect.topLeft, Offset(rect.left + cornerLength, rect.top),
          Offset(rect.left, rect.top + cornerLength)],
      [rect.topRight, Offset(rect.right - cornerLength, rect.top),
          Offset(rect.right, rect.top + cornerLength)],
      [rect.bottomLeft, Offset(rect.left + cornerLength, rect.bottom),
          Offset(rect.left, rect.bottom - cornerLength)],
      [rect.bottomRight, Offset(rect.right - cornerLength, rect.bottom),
          Offset(rect.right, rect.bottom - cornerLength)],
    ];

    // Draw corner markers
    for (final corner in corners) {
      canvas.drawLine(corner[0] as Offset, corner[1] as Offset, paint);
      canvas.drawLine(corner[0] as Offset, corner[2] as Offset, paint);
    }

    // Draw grid lines with lower opacity
    paint
      ..color = Colors.white.withOpacity(0.1)
      ..strokeWidth = 1.0;

    // Draw 15x15 grid
    for (int i = 1; i < 15; i++) {
      // Vertical lines
      final x = left + (squareSize / 15) * i;
      canvas.drawLine(
        Offset(x, top),
        Offset(x, top + squareSize),
        paint,
      );

      // Horizontal lines
      final y = top + (squareSize / 15) * i;
      canvas.drawLine(
        Offset(left, y),
        Offset(left + squareSize, y),
        paint,
      );
    }
  }

  @override
  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;
}```\n
\n### src/widgets/move_history_widget.dart\n
```dart
// lib/src/widgets/move_history_widget.dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:intl/intl.dart';
import '../providers/game_session_provider.dart';
import '../services/firebase_service.dart';

class MoveHistoryWidget extends StatelessWidget {
  const MoveHistoryWidget({super.key});

  @override
  Widget build(BuildContext context) {
    return Card(
      margin: const EdgeInsets.all(16),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.stretch,
        children: [
          Container(
            padding: const EdgeInsets.all(16),
            decoration: BoxDecoration(
              border: Border(
                bottom: BorderSide(
                  color: Theme.of(context).dividerColor,
                ),
              ),
            ),
            child: const Text(
              'Move History',
              style: TextStyle(
                fontSize: 18,
                fontWeight: FontWeight.bold,
              ),
            ),
          ),
          Expanded(
            child: _buildMoveList(),
          ),
        ],
      ),
    );
  }

  Widget _buildMoveList() {
    return Consumer<GameSessionProvider>(
      builder: (context, provider, child) {
        return StreamBuilder<List<Map<String, dynamic>>>(
          stream: FirebaseService().getSessionMoves(provider.currentSession!.id),
          builder: (context, snapshot) {
            if (snapshot.hasError) {
              return Center(child: Text('Error: ${snapshot.error}'));
            }

            if (!snapshot.hasData) {
              return const Center(child: CircularProgressIndicator());
            }

            final moves = snapshot.data!;
            if (moves.isEmpty) {
              return const Center(child: Text('No moves yet'));
            }

            return ListView.builder(
              itemCount: moves.length,
              itemBuilder: (context, index) {
                final move = moves[index];
                return _buildMoveItem(context, move, index + 1);
              },
            );
          },
        );
      },
    );
  }

  Widget _buildMoveItem(BuildContext context, Map<String, dynamic> move, int moveNumber) {
    final timestamp = move['timestamp'] as DateTime;
    final isPlayer1 = move['playerId'] == 'p1';
    final provider = context.read<GameSessionProvider>();
    final playerName = isPlayer1 
        ? provider.currentSession!.player1Name 
        : provider.currentSession!.player2Name;

    return ListTile(
      leading: CircleAvatar(
        backgroundColor: isPlayer1 ? Colors.blue[300] : Colors.green[300],
        child: Text(
          move['word'][0],
          style: const TextStyle(color: Colors.white),
        ),
      ),
      title: Text(move['word']),
      subtitle: Text('$playerName - ${move['score']} points'),
      trailing: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        crossAxisAlignment: CrossAxisAlignment.end,
        children: [
          Text(
            '#$moveNumber',
            style: Theme.of(context).textTheme.bodySmall,
          ),
          Text(
            DateFormat.jm().format(timestamp),
            style: Theme.of(context).textTheme.bodySmall,
          ),
        ],
      ),
      onTap: () => _showMoveDetails(context, move),
    );
  }

  void _showMoveDetails(BuildContext context, Map<String, dynamic> move) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: Text('Move #${move['word']}'),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text('Score: ${move['score']} points'),
            const SizedBox(height: 8),
            Text('Player: ${move['playerId'] == 'p1' ? 'Player 1' : 'Player 2'}'),
            const SizedBox(height: 8),
            Text('Time: ${DateFormat.jm().format(move['timestamp'] as DateTime)}'),
            if (move['tiles'] != null) ...[
              const SizedBox(height: 16),
              const Text('Tiles placed:'),
              const SizedBox(height: 8),
              Wrap(
                spacing: 8,
                children: [
                  for (final tile in move['tiles'])
                    Chip(
                      label: Text('${tile['letter']} (${tile['points']})'),
                    ),
                ],
              ),
            ],
          ],
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('Close'),
          ),
        ],
      ),
    );
  }
}```\n
\n### src/widgets/player_info_widget.dart\n
```dart
// lib/src/widgets/player_info_widget.dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../providers/game_session_provider.dart';
import '../services/firebase_service.dart';

class PlayerInfoWidget extends StatelessWidget {
  final String player1Name;
  final String player2Name;
  final VoidCallback? onPlayer1Selected;
  final VoidCallback? onPlayer2Selected;

  const PlayerInfoWidget({
    super.key,
    required this.player1Name,
    required this.player2Name,
    this.onPlayer1Selected,
    this.onPlayer2Selected,
  });

  @override
  Widget build(BuildContext context) {
    return Card(
      margin: const EdgeInsets.all(16),
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Row(
          children: [
            Expanded(
              child: _buildPlayerInfo(
                context,
                name: player1Name,
                playerId: 'p1',
                color: Colors.blue[300]!,
                onTap: onPlayer1Selected,
              ),
            ),
            Container(
              height: 40,
              width: 2,
              color: Colors.grey[300],
            ),
            Expanded(
              child: _buildPlayerInfo(
                context,
                name: player2Name,
                playerId: 'p2',
                color: Colors.green[300]!,
                onTap: onPlayer2Selected,
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildPlayerInfo(
    BuildContext context, {
    required String name,
    required String playerId,
    required Color color,
    VoidCallback? onTap,
  }) {
    return StreamBuilder<int>(
      stream: FirebaseService().getPlayerScore(
        context.read<GameSessionProvider>().currentSession!.id,
        playerId,
      ),
      builder: (context, snapshot) {
        final score = snapshot.data ?? 0;
        final isCurrentPlayer = context.select(
          (GameSessionProvider p) => p.currentSession?.currentPlayerId == playerId,
        );

        return InkWell(
          onTap: onTap,
          borderRadius: BorderRadius.circular(8),
          child: Container(
            padding: const EdgeInsets.all(8),
            decoration: BoxDecoration(
              borderRadius: BorderRadius.circular(8),
              border: isCurrentPlayer
                  ? Border.all(color: color, width: 2)
                  : null,
            ),
            child: Column(
              children: [
                Row(
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                    CircleAvatar(
                      backgroundColor: color,
                      radius: 16,
                      child: Text(
                        name[0],
                        style: const TextStyle(
                          color: Colors.white,
                          fontWeight: FontWeight.bold,
                        ),
                      ),
                    ),
                    const SizedBox(width: 8),
                    Flexible(
                      child: Text(
                        name,
                        style: const TextStyle(
                          fontSize: 16,
                          fontWeight: FontWeight.bold,
                        ),
                        overflow: TextOverflow.ellipsis,
                      ),
                    ),
                  ],
                ),
                const SizedBox(height: 8),
                Text(
                  'Score: $score',
                  style: TextStyle(
                    fontSize: 20,
                    fontWeight: FontWeight.bold,
                    color: color,
                  ),
                ),
                if (isCurrentPlayer) ...[
                  const SizedBox(height: 4),
                  Container(
                    padding: const EdgeInsets.symmetric(
                      horizontal: 8,
                      vertical: 2,
                    ),
                    decoration: BoxDecoration(
                      color: color.withOpacity(0.2),
                      borderRadius: BorderRadius.circular(12),
                    ),
                    child: const Text(
                      'Current Turn',
                      style: TextStyle(fontSize: 12),
                    ),
                  ),
                ],
              ],
            ),
          ),
        );
      },
    );
  }
}```\n
\n### src/widgets/camera_overlay_widget.dart\n
```dart
```\n
\n### src/widgets/recognition_metrics_viewer.dart\n
```dart
import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import 'package:oloodi_scrabble_moderator_app/src/services/recognition_metrics_service.dart';

class MetricsViewer extends StatelessWidget {
  final String sessionId;
  final RecognitionMetricsService _metricsService = RecognitionMetricsService();

  MetricsViewer({super.key, required this.sessionId});

  @override
  Widget build(BuildContext context) {
    return FutureBuilder<List<RecognitionMetrics>>(
      future: _metricsService.getSessionMetrics(sessionId),
      builder: (context, snapshot) {
        if (snapshot.connectionState == ConnectionState.waiting) {
          return const Center(child: CircularProgressIndicator());
        }

        if (snapshot.hasError) {
          return Center(child: Text('Error: ${snapshot.error}'));
        }

        final metrics = snapshot.data ?? [];
        if (metrics.isEmpty) {
          return const Center(child: Text('No recognition metrics available'));
        }

        final totalAccuracy = metrics.fold<double>(
          0,
          (sum, metric) =>
              sum +
              ((metric.totalTiles - metric.correctedTiles) / metric.totalTiles),
        );
        final averageAccuracy = totalAccuracy / metrics.length;

        return Card(
          child: Padding(
            padding: const EdgeInsets.all(16),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  'Recognition Accuracy: ${(averageAccuracy * 100).toStringAsFixed(1)}%',
                  style: Theme.of(context).textTheme.titleLarge,
                ),
                const SizedBox(height: 16),
                Text('Total Moves: ${metrics.length}'),
                Text(
                    'Total Corrections: ${metrics.fold<int>(0, (sum, m) => sum + m.correctedTiles)}'),
                const SizedBox(height: 16),
                const Text('Recent Corrections:'),
                Expanded(
                  child: ListView.builder(
                    itemCount: metrics.length,
                    itemBuilder: (context, index) {
                      final metric = metrics[index];
                      return ListTile(
                        title: Text('Move ${index + 1}'),
                        subtitle: Text(
                          'Accuracy: ${((metric.totalTiles - metric.correctedTiles) / metric.totalTiles * 100).toStringAsFixed(1)}% '
                          '(${metric.correctedTiles} corrections)',
                        ),
                        trailing: Text(
                          DateFormat.yMd().add_jm().format(metric.timestamp),
                          style: Theme.of(context).textTheme.bodySmall,
                        ),
                      );
                    },
                  ),
                ),
              ],
            ),
          ),
        );
      },
    );
  }
}
```\n
\n### src/widgets/board_preview_widget_2.dart\n
```dart
// lib/src/widgets/board_preview_widget.dart
import 'package:flutter/material.dart';
import '../models/board_square.dart';
import '../services/score_calculator.dart';

class BoardPreviewWidget extends StatelessWidget {
  final List<Map<String, dynamic>> newTiles;
  final List<List<BoardSquare>> currentBoard;
  final bool isFirstMove;

  const BoardPreviewWidget({
    super.key,
    required this.newTiles,
    required this.currentBoard,
    required this.isFirstMove,
  });

  @override
  Widget build(BuildContext context) {
    return SizedBox(
      width: 300,
      height: 300,
      child: GridView.builder(
        gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
          crossAxisCount: 15,
          childAspectRatio: 1,
        ),
        itemCount: 225,
        itemBuilder: (context, index) {
          final row = index ~/ 15;
          final col = index % 15;
          
          // Find if there's a new tile at this position
          final newTile = newTiles.firstWhere(
            (tile) => tile['row'] == row && tile['col'] == col,
            orElse: () => {'letter': null},
          );

          // Get existing tile
          final existingTile = currentBoard[row][col].tile;
          
          // Get square type
          final squareType = ScoreCalculator.getSquareType(row, col);
          
          return _buildSquare(
            context,
            row: row,
            col: col,
            squareType: squareType,
            newTile: newTile['letter'] != null ? newTile : null,
            existingTile: existingTile,
          );
        },
      ),
    );
  }

  Widget _buildSquare(
    BuildContext context, {
    required int row,
    required int col,
    required SquareType squareType,
    Map<String, dynamic>? newTile,
    dynamic existingTile,
  }) {
    final isNewTilePlacement = newTile != null;
    final hasExistingTile = existingTile != null;
    
    Color getBackgroundColor() {
      if (isNewTilePlacement) return Colors.yellow[100]!;
      if (hasExistingTile) return Colors.brown[100]!;
      
      switch (squareType) {
        case SquareType.tripleWord:
          return Colors.red[100]!;
        case SquareType.doubleWord:
          return Colors.pink[50]!;
        case SquareType.tripleLetter:
          return Colors.blue[100]!;
        case SquareType.doubleLetter:
          return Colors.lightBlue[50]!;
        default:
          return Colors.white;
      }
    }

    String getMultiplierLabel() {
      switch (squareType) {
        case SquareType.tripleWord:
          return 'TW';
        case SquareType.doubleWord:
          return 'DW';
        case SquareType.tripleLetter:
          return 'TL';
        case SquareType.doubleLetter:
          return 'DL';
        default:
          return '';
      }
    }

    return Container(
      decoration: BoxDecoration(
        color: getBackgroundColor(),
        border: Border.all(color: Colors.grey[300]!),
      ),
      child: Stack(
        children: [
          if (!isNewTilePlacement && !hasExistingTile && getMultiplierLabel().isNotEmpty)
            Center(
              child: Text(
                getMultiplierLabel(),
                style: TextStyle(
                  fontSize: 8,
                  color: Colors.grey[600],
                ),
              ),
            ),
          if (isNewTilePlacement || hasExistingTile)
            Center(
              child: Container(
                padding: const EdgeInsets.all(2),
                decoration: BoxDecoration(
                  color: isNewTilePlacement ? Colors.yellow : Colors.brown[200],
                  borderRadius: BorderRadius.circular(2),
                ),
                child: Text(
                  isNewTilePlacement ? newTile!['letter'] : existingTile.letter,
                  style: TextStyle(
                    fontSize: 10,
                    fontWeight: FontWeight.bold,
                    color: isNewTilePlacement ? Colors.black : Colors.white,
                  ),
                ),
              ),
            ),
          if (row == 7 && col == 7 && !hasExistingTile && !isNewTilePlacement)
            const Center(
              child: Text(
                'â˜…',
                style: TextStyle(
                  fontSize: 12,
                  color: Colors.pink,
                ),
              ),
            ),
        ],
      ),
    );
  }
}```\n
\n## pubspec.yaml\n
```yaml
name: oloodi_scrabble_moderator_app
description: Moderator app for Scrabble game management.
publish_to: 'none'
version: 1.0.0+1

environment:
  sdk: '>=3.0.0 <4.0.0'

dependencies:
  flutter:
    sdk: flutter
  cupertino_icons: ^1.0.2
  provider: ^6.1.1
  firebase_core: ^2.32.0
  cloud_firestore: ^4.13.6
  camera: ^0.10.5+9
  qr_flutter: ^4.1.0
  path_provider: ^2.1.5
  uuid: ^4.3.3
  intl: ^0.18.1
  permission_handler: ^11.3.1
  flutter_dotenv: ^5.2.1
  firebase_storage: ^11.6.5
  json_annotation: ^4.9.0
  image_cropper: ^8.1.0
  firebase_vertexai: ^0.1.0

dev_dependencies:
  flutter_test:
    sdk: flutter
  flutter_lints: ^3.0.1
  json_serializable: ^6.9.0
  build_runner: ^2.4.13

flutter:
  uses-material-design: true
  assets:
    - assets/images/
    - assets/icons/
    - .env```
