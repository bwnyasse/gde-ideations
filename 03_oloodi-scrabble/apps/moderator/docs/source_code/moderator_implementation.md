# Source Code Documentation
\n## Project Structure\n
\n### firebase_options.dart\n
```dart
// File generated by FlutterFire CLI.
// ignore_for_file: type=lint
import 'package:firebase_core/firebase_core.dart' show FirebaseOptions;
import 'package:flutter/foundation.dart'
    show defaultTargetPlatform, kIsWeb, TargetPlatform;

/// Default [FirebaseOptions] for use with your Firebase apps.
///
/// Example:
/// ```dart
/// import 'firebase_options.dart';
/// // ...
/// await Firebase.initializeApp(
///   options: DefaultFirebaseOptions.currentPlatform,
/// );
/// ```
class DefaultFirebaseOptions {
  static FirebaseOptions get currentPlatform {
    if (kIsWeb) {
      throw UnsupportedError(
        'DefaultFirebaseOptions have not been configured for web - '
        'you can reconfigure this by running the FlutterFire CLI again.',
      );
    }
    switch (defaultTargetPlatform) {
      case TargetPlatform.android:
        return android;
      case TargetPlatform.iOS:
        throw UnsupportedError(
          'DefaultFirebaseOptions have not been configured for ios - '
          'you can reconfigure this by running the FlutterFire CLI again.',
        );
      case TargetPlatform.macOS:
        throw UnsupportedError(
          'DefaultFirebaseOptions have not been configured for macos - '
          'you can reconfigure this by running the FlutterFire CLI again.',
        );
      case TargetPlatform.windows:
        throw UnsupportedError(
          'DefaultFirebaseOptions have not been configured for windows - '
          'you can reconfigure this by running the FlutterFire CLI again.',
        );
      case TargetPlatform.linux:
        throw UnsupportedError(
          'DefaultFirebaseOptions have not been configured for linux - '
          'you can reconfigure this by running the FlutterFire CLI again.',
        );
      default:
        throw UnsupportedError(
          'DefaultFirebaseOptions are not supported for this platform.',
        );
    }
  }

  static const FirebaseOptions android = FirebaseOptions(
    apiKey: 'AIzaSyCHk-o2MoCxroAM5rjhVsGI77RZi2drqfM',
    appId: '1:553140087820:android:a8c79c54f1da5c6ed51229',
    messagingSenderId: '553140087820',
    projectId: 'learning-box-369917',
    storageBucket: 'learning-box-369917.firebasestorage.app',
  );

}```\n
\n### main.dart\n
```dart
import 'package:flutter/material.dart';
import 'package:oloodi_scrabble_moderator_app/src/screens/game_sessions_list_screen.dart';
import 'package:provider/provider.dart';
import 'src/providers/game_session_provider.dart';
import 'src/themes/app_theme.dart';
import 'package:firebase_core/firebase_core.dart';
import 'firebase_options.dart';

void main() async {
  WidgetsFlutterBinding.ensureInitialized();
  await Firebase.initializeApp(
    options: DefaultFirebaseOptions.currentPlatform,
  );
  runApp(const ModeratorApp());
}

class ModeratorApp extends StatelessWidget {
  const ModeratorApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MultiProvider(
      providers: [
        ChangeNotifierProvider(create: (_) => GameSessionProvider()),
      ],
      child: MaterialApp(
        title: 'Scrabble Moderator',
        theme: AppTheme.theme,
        home: const GameSessionsListScreen(),
      ),
    );
  }
}
```\n
\n### src/config/env_config.dart\n
```dart
// lib/config/env_config.dart
import 'package:flutter_dotenv/flutter_dotenv.dart';

class EnvConfig {
  static String get geminiApiKey {
    try {
      return dotenv.get('GEMINI_API_KEY', fallback: '');
    } catch (e) {
      return '';
    }
  }

  static String get elevenLabsApiKey {
    try {
      return dotenv.get('ELEVEN_LABS_API_KEY', fallback: '');
    } catch (e) {
      return '';
    }
  }

  static String get elevenLabsVoiceId {
    try {
      return dotenv.get('ELEVEN_LABS_VOICE_ID', fallback: '');
    } catch (e) {
      return '';
    }
  }

  static bool get isConfigured {
    return geminiApiKey.isNotEmpty && 
           elevenLabsApiKey.isNotEmpty && 
           elevenLabsVoiceId.isNotEmpty;
  }

  static List<String> getMissingConfigurations() {
    final missing = <String>[];
    
    if (geminiApiKey.isEmpty) {
      missing.add('Gemini API Key');
    }
    if (elevenLabsApiKey.isEmpty) {
      missing.add('ElevenLabs API Key');
    }
    if (elevenLabsVoiceId.isEmpty) {
      missing.add('ElevenLabs Voice ID');
    }
    
    return missing;
  }
}```\n
\n### src/providers/game_session_provider.dart\n
```dart
import 'package:flutter/foundation.dart';
import '../models/game_session.dart';
import '../services/firebase_service.dart';
import '../services/qr_service.dart';

class GameSessionProvider with ChangeNotifier {
  final FirebaseService _firebaseService = FirebaseService();
  final QRService _qrService = QRService();

  GameSession? _currentSession;
  bool _isLoading = false;
  String? _error;

  // Getters
  GameSession? get currentSession => _currentSession;
  bool get isLoading => _isLoading;
  String? get error => _error;
  bool get hasActiveSession => _currentSession != null && _currentSession!.isActive;

  // Create new game session
  Future<void> createGameSession(String player1Name, String player2Name) async {
    try {
      _setLoading(true);
      _clearError();

      // Create session in Firebase
      final session = await _firebaseService.createGameSession(
        player1Name: player1Name,
        player2Name: player2Name,
      );

      // Generate QR code data string
      final qrCodeData = _qrService.generateQRCodeData(session.id);

      // Update session with QR code data
      _currentSession = await _firebaseService.updateSessionQRCode(
        session.id,
        qrCodeData,
      );

      notifyListeners();
    } catch (e) {
      _setError('Failed to create game session: $e');
    } finally {
      _setLoading(false);
    }
  }

  // Add move to current session
  Future<void> addMove({
    required String word,
    required int score,
    required String playerId,
    required List<Map<String, dynamic>> tiles,
  }) async {
    if (_currentSession == null) {
      _setError('No active session');
      return;
    }

    try {
      _setLoading(true);
      _clearError();

      await _firebaseService.addMoveToSession(
        sessionId: _currentSession!.id,
        word: word,
        score: score,
        playerId: playerId,
        tiles: tiles,
      );

      notifyListeners();
    } catch (e) {
      _setError('Failed to add move: $e');
    } finally {
      _setLoading(false);
    }
  }

  // Update board state
  Future<void> updateBoardState(
    String sessionId,
    List<Map<String, dynamic>> tiles,
  ) async {
    try {
      _setLoading(true);
      _clearError();

      // Update in Firebase using tiles directly
      await _firebaseService.updateBoardState(sessionId, tiles);

      notifyListeners();
    } catch (e) {
      _setError('Failed to update board state: $e');
      throw e;
    } finally {
      _setLoading(false);
    }
  }

  // Load existing session
  Future<void> loadSession(String sessionId) async {
    try {
      _setLoading(true);
      _clearError();

      _currentSession = await _firebaseService.getSession(sessionId);
      notifyListeners();
    } catch (e) {
      _setError('Failed to load session: $e');
    } finally {
      _setLoading(false);
    }
  }

  // End current session
  Future<void> endCurrentSession() async {
    if (_currentSession == null) return;

    try {
      _setLoading(true);
      _clearError();

      await _firebaseService.updateSessionStatus(
        _currentSession!.id,
        false,
      );

      _currentSession = null;
      notifyListeners();
    } catch (e) {
      _setError('Failed to end session: $e');
    } finally {
      _setLoading(false);
    }
  }

  // Get all sessions
  Stream<List<GameSession>> getSessions() {
    return _firebaseService.getGameSessions().map((snapshot) => snapshot.docs
        .map((doc) => GameSession.fromJson(doc.data() as Map<String, dynamic>))
        .toList());
  }

  // Delete multiple sessions
  Future<void> deleteSessions(List<String> sessionIds) async {
    try {
      _setLoading(true);
      _clearError();

      for (final sessionId in sessionIds) {
        await _firebaseService.deleteSession(sessionId);
      }
    } catch (e) {
      _setError('Failed to delete sessions: $e');
      rethrow;
    } finally {
      _setLoading(false);
    }
  }

  // Get session statistics
  Future<Map<String, dynamic>> getSessionStats(String sessionId) async {
    try {
      final moves = await _firebaseService.getSessionMoves(sessionId).first;
      final remainingLetters = await _firebaseService.getRemainingLetters(sessionId);

      return {
        'totalMoves': moves.length,
        'remainingLetters': remainingLetters,
        'player1Score': moves
            .where((m) => m['playerId'] == 'p1')
            .fold(0, (sum, m) => sum + (m['score'] as int)),
        'player2Score': moves
            .where((m) => m['playerId'] == 'p2')
            .fold(0, (sum, m) => sum + (m['score'] as int)),
      };
    } catch (e) {
      _setError('Failed to get session stats: $e');
      rethrow;
    }
  }

  // Helper methods
  void _setLoading(bool loading) {
    _isLoading = loading;
    notifyListeners();
  }

  void _setError(String error) {
    _error = error;
    notifyListeners();
  }

  void _clearError() {
    _error = null;
  }
}```\n
\n### src/models/game_session.g.dart\n
```dart
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'game_session.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

Move _$MoveFromJson(Map<String, dynamic> json) => Move(
      word: json['word'] as String,
      score: (json['score'] as num).toInt(),
      tiles: (json['tiles'] as List<dynamic>)
          .map((e) => e as Map<String, dynamic>)
          .toList(),
      playerId: json['playerId'] as String,
      timestamp: Move._timestampFromJson(json['timestamp'] as Timestamp),
      imagePath: json['imagePath'] as String?,
    );

Map<String, dynamic> _$MoveToJson(Move instance) => <String, dynamic>{
      'word': instance.word,
      'score': instance.score,
      'tiles': instance.tiles,
      'playerId': instance.playerId,
      'timestamp': Move._timestampToJson(instance.timestamp),
      'imagePath': instance.imagePath,
    };

GameSession _$GameSessionFromJson(Map<String, dynamic> json) => GameSession(
      id: json['id'] as String,
      player1Name: json['player1Name'] as String,
      player2Name: json['player2Name'] as String,
      startTime: GameSession._timestampFromJson(json['startTime'] as Timestamp),
      qrCode: json['qrCode'] as String?,
      currentPlayerId: json['currentPlayerId'] as String? ?? 'p1',
      moves: (json['moves'] as List<dynamic>?)
              ?.map((e) => Move.fromJson(e as Map<String, dynamic>))
              .toList() ??
          [],
      isActive: json['isActive'] as bool? ?? true,
    );

Map<String, dynamic> _$GameSessionToJson(GameSession instance) =>
    <String, dynamic>{
      'id': instance.id,
      'player1Name': instance.player1Name,
      'player2Name': instance.player2Name,
      'startTime': GameSession._timestampToJson(instance.startTime),
      'qrCode': instance.qrCode,
      'currentPlayerId': instance.currentPlayerId,
      'moves': instance.moves,
      'isActive': instance.isActive,
    };
```\n
\n### src/models/game_session.dart\n
```dart
// move.dart
import 'package:json_annotation/json_annotation.dart';
import 'package:cloud_firestore/cloud_firestore.dart';

part 'game_session.g.dart';

@JsonSerializable()
class Move {
  final String word;
  final int score;
  final List<Map<String, dynamic>> tiles;
  final String playerId;
  @JsonKey(fromJson: _timestampFromJson, toJson: _timestampToJson)
  final DateTime timestamp;
  final String? imagePath;

  Move({
    required this.word,
    required this.score,
    required this.tiles,
    required this.playerId,
    required this.timestamp,
    this.imagePath,
  });

  factory Move.fromJson(Map<String, dynamic> json) => _$MoveFromJson(json);
  Map<String, dynamic> toJson() => _$MoveToJson(this);

  static DateTime _timestampFromJson(Timestamp timestamp) => timestamp.toDate();
  static Timestamp _timestampToJson(DateTime date) => Timestamp.fromDate(date);
}

@JsonSerializable()
class GameSession {
  final String id;
  final String player1Name;
  final String player2Name;
  @JsonKey(fromJson: _timestampFromJson, toJson: _timestampToJson)
  final DateTime startTime;
  final String? qrCode;
  final String currentPlayerId;
  @JsonKey(defaultValue: [])
  final List<Move> moves;
  final bool isActive;

  GameSession({
    required this.id,
    required this.player1Name,
    required this.player2Name,
    required this.startTime,
    this.qrCode,
    this.currentPlayerId = 'p1',
    this.moves = const [],
    this.isActive = true,
  });

  factory GameSession.fromJson(Map<String, dynamic> json) =>
      _$GameSessionFromJson(json);
  Map<String, dynamic> toJson() => _$GameSessionToJson(this);

  static DateTime _timestampFromJson(Timestamp timestamp) => timestamp.toDate();
  static Timestamp _timestampToJson(DateTime date) => Timestamp.fromDate(date);

  String getNextPlayerId() => currentPlayerId == 'p1' ? 'p2' : 'p1';
  Move? get lastMove => moves.isNotEmpty ? moves.last : null;
}```\n
\n### src/screens/game_monitoring_screen.dart\n
```dart
// lib/src/screens/game_monitoring_screen.dart
import 'package:flutter/material.dart';
import 'package:oloodi_scrabble_moderator_app/src/services/qr_service.dart';
import 'package:provider/provider.dart';
import '../providers/game_session_provider.dart';
import '../widgets/move_history_widget.dart';
import '../widgets/player_info_widget.dart';
import 'move_capture_screen.dart';

class GameMonitoringScreen extends StatelessWidget {
  final String sessionId;

  const GameMonitoringScreen({
    super.key,
    required this.sessionId,
  });

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Game Monitoring'),
        actions: [
          IconButton(
            icon: const Icon(Icons.qr_code),
            onPressed: () => _showQRCode(context),
          ),
          IconButton(
            icon: const Icon(Icons.stop),
            onPressed: () => _endGame(context),
          ),
        ],
      ),
      body: FutureBuilder<void>(
        future: context.read<GameSessionProvider>().loadSession(sessionId),
        builder: (context, snapshot) {
          if (snapshot.hasError) {
            return Center(child: Text('Error: ${snapshot.error}'));
          }

          return Consumer<GameSessionProvider>(
            builder: (context, provider, child) {
              if (provider.isLoading) {
                return const Center(child: CircularProgressIndicator());
              }

              if (provider.error != null) {
                return Center(child: Text(provider.error!));
              }

              if (provider.currentSession == null) {
                return const Center(child: Text('Session not found'));
              }

              return Column(
                children: [
                  // Player information
                  PlayerInfoWidget(
                    player1Name: provider.currentSession!.player1Name,
                    player2Name: provider.currentSession!.player2Name,
                  ),
                  
                  // Move history
                  const Expanded(
                    child: MoveHistoryWidget(),
                  ),
                ],
              );
            },
          );
        },
      ),
      floatingActionButton: FloatingActionButton.extended(
        onPressed: () => _captureMove(context),
        icon: const Icon(Icons.camera_alt),
        label: const Text('Capture Move'),
      ),
    );
  }

  void _showQRCode(BuildContext context) {
    Navigator.push(
      context,
      MaterialPageRoute(
        builder: (_) => QRDisplayScreen(sessionId: sessionId),
      ),
    );
  }

  void _captureMove(BuildContext context) {
    Navigator.push(
      context,
      MaterialPageRoute(
        builder: (_) => const MoveCaptureScreen(),
      ),
    );
  }

  Future<void> _endGame(BuildContext context) async {
    final confirmed = await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('End Game'),
        content: const Text('Are you sure you want to end this game?'),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context, false),
            child: const Text('Cancel'),
          ),
          TextButton(
            onPressed: () => Navigator.pop(context, true),
            child: const Text('End Game'),
          ),
        ],
      ),
    );

    if (confirmed != true || !context.mounted) return;

    try {
      await context.read<GameSessionProvider>().endCurrentSession();
      if (!context.mounted) return;
      Navigator.of(context).popUntil((route) => route.isFirst);
    } catch (e) {
      if (!context.mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Failed to end game: $e')),
      );
    }
  }
}```\n
\n### src/screens/game_sessions_list_screen.dart\n
```dart
// lib/src/screens/game_sessions_list_screen.dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:intl/intl.dart';
import '../providers/game_session_provider.dart';
import '../models/game_session.dart';
import 'game_setup_screen.dart';
import 'game_monitoring_screen.dart';

class GameSessionsListScreen extends StatefulWidget {
  const GameSessionsListScreen({super.key});

  @override
  State<GameSessionsListScreen> createState() => _GameSessionsListScreenState();
}

class _GameSessionsListScreenState extends State<GameSessionsListScreen> {
  final Set<String> _selectedSessions = {};

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Game Sessions'),
        actions: [
          if (_selectedSessions.isNotEmpty)
            IconButton(
              icon: const Icon(Icons.delete),
              onPressed: _deleteSelectedSessions,
            ),
        ],
      ),
      body: StreamBuilder<List<GameSession>>(
        stream: context.read<GameSessionProvider>().getSessions(),
        builder: (context, snapshot) {
          if (snapshot.hasError) {
            return Center(
              child: Text('Error: ${snapshot.error}'),
            );
          }

          if (snapshot.connectionState == ConnectionState.waiting) {
            return const Center(
              child: CircularProgressIndicator(),
            );
          }

          final sessions = snapshot.data ?? [];
          if (sessions.isEmpty) {
            return Center(
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  const Icon(Icons.sports_esports_outlined, size: 64, color: Colors.grey),
                  const SizedBox(height: 16),
                  const Text(
                    'No game sessions yet',
                    style: TextStyle(fontSize: 18, color: Colors.grey),
                  ),
                  const SizedBox(height: 8),
                  const Text(
                    'Create a new game to get started',
                    style: TextStyle(color: Colors.grey),
                  ),
                ],
              ),
            );
          }

          return ListView.builder(
            itemCount: sessions.length,
            itemBuilder: (context, index) {
              final session = sessions[index];
              return _buildSessionCard(session);
            },
          );
        },
      ),
      floatingActionButton: FloatingActionButton.extended(
        onPressed: () => _navigateToGameSetup(context),
        icon: const Icon(Icons.add),
        label: const Text('Start Game'),
      ),
    );
  }

  Widget _buildSessionCard(GameSession session) {
    final dateFormat = DateFormat('MMM d, y â€“ h:mm a');
    final isSelected = _selectedSessions.contains(session.id);

    return Card(
      margin: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
      child: InkWell(
        onTap: () => _navigateToSession(session),
        onLongPress: () => _toggleSessionSelection(session.id),
        child: Container(
          padding: const EdgeInsets.all(16),
          color: isSelected ? Colors.blue.withOpacity(0.1) : null,
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Row(
                children: [
                  Expanded(
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Row(
                          children: [
                            Text(
                              '${session.player1Name} vs ${session.player2Name}',
                              style: const TextStyle(
                                fontSize: 16,
                                fontWeight: FontWeight.bold,
                              ),
                            ),
                            if (session.isActive)
                              Container(
                                margin: const EdgeInsets.only(left: 8),
                                padding: const EdgeInsets.symmetric(
                                  horizontal: 8,
                                  vertical: 2,
                                ),
                                decoration: BoxDecoration(
                                  color: Colors.green,
                                  borderRadius: BorderRadius.circular(12),
                                ),
                                child: const Text(
                                  'Active',
                                  style: TextStyle(
                                    color: Colors.white,
                                    fontSize: 12,
                                  ),
                                ),
                              ),
                          ],
                        ),
                        const SizedBox(height: 4),
                        Text(
                          dateFormat.format(session.startTime),
                          style: TextStyle(
                            color: Colors.grey[600],
                            fontSize: 12,
                          ),
                        ),
                      ],
                    ),
                  ),
                  if (isSelected)
                    const Icon(Icons.check_circle, color: Colors.blue)
                  else
                    const Icon(Icons.chevron_right, color: Colors.grey),
                ],
              ),
              if (session.isActive) ...[
                const SizedBox(height: 16),
                _buildGameStats(session),
              ],
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildGameStats(GameSession session) {
    return FutureBuilder<Map<String, dynamic>>(
      future: context.read<GameSessionProvider>().getSessionStats(session.id),
      builder: (context, snapshot) {
        if (!snapshot.hasData) {
          return const SizedBox();
        }

        final stats = snapshot.data!;
        return Row(
          mainAxisAlignment: MainAxisAlignment.spaceAround,
          children: [
            _buildStatItem('Moves', stats['totalMoves']?.toString() ?? '0'),
            _buildStatItem('Letters Remaining', stats['remainingLetters']?.toString() ?? '-'),
            _buildStatItem('Duration', _formatDuration(session.startTime)),
          ],
        );
      },
    );
  }

  Widget _buildStatItem(String label, String value) {
    return Column(
      children: [
        Text(
          value,
          style: const TextStyle(
            fontSize: 16,
            fontWeight: FontWeight.bold,
          ),
        ),
        Text(
          label,
          style: TextStyle(
            fontSize: 12,
            color: Colors.grey[600],
          ),
        ),
      ],
    );
  }

  String _formatDuration(DateTime startTime) {
    final duration = DateTime.now().difference(startTime);
    final hours = duration.inHours;
    final minutes = duration.inMinutes % 60;
    return '${hours}h ${minutes}m';
  }

  void _toggleSessionSelection(String sessionId) {
    setState(() {
      if (_selectedSessions.contains(sessionId)) {
        _selectedSessions.remove(sessionId);
      } else {
        _selectedSessions.add(sessionId);
      }
    });
  }

  Future<void> _deleteSelectedSessions() async {
    final confirmed = await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Delete Sessions'),
        content: Text(
          'Are you sure you want to delete ${_selectedSessions.length} selected session(s)?',
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context, false),
            child: const Text('Cancel'),
          ),
          TextButton(
            onPressed: () => Navigator.pop(context, true),
            child: const Text('Delete'),
          ),
        ],
      ),
    );

    if (confirmed == true && mounted) {
      try {
        await context.read<GameSessionProvider>().deleteSessions(_selectedSessions.toList());
        setState(() {
          _selectedSessions.clear();
        });
      } catch (e) {
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(content: Text('Error deleting sessions: $e')),
          );
        }
      }
    }
  }

  void _navigateToSession(GameSession session) {
    Navigator.push(
      context,
      MaterialPageRoute(
        builder: (context) => GameMonitoringScreen(sessionId: session.id),
      ),
    );
  }

  void _navigateToGameSetup(BuildContext context) {
    Navigator.push(
      context,
      MaterialPageRoute(
        builder: (context) => const GameSetupScreen(),
      ),
    );
  }
}```\n
\n### src/screens/qr_display_screen.dart\n
```dart
```\n
\n### src/screens/move_capture_screen.dart\n
```dart
import 'package:camera/camera.dart';
import 'package:flutter/material.dart';
import 'package:permission_handler/permission_handler.dart';
import 'package:provider/provider.dart';
import '../providers/game_session_provider.dart';
import '../services/gemini_service.dart';

class MoveCaptureScreen extends StatefulWidget {
  const MoveCaptureScreen({super.key});

  @override
  State<MoveCaptureScreen> createState() => _MoveCaptureScreenState();
}

class _MoveCaptureScreenState extends State<MoveCaptureScreen>
    with WidgetsBindingObserver {
  CameraController? _controller;
  bool _isCameraInitialized = false;
  String? _error;
  bool _processing = false;
  final GeminiService _geminiService = GeminiService();

  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addObserver(this);
    _requestCameraPermission();
  }

  @override
  void dispose() {
    WidgetsBinding.instance.removeObserver(this);
    _controller?.dispose();
    super.dispose();
  }

  @override
  void didChangeAppLifecycleState(AppLifecycleState state) {
    if (state == AppLifecycleState.inactive) {
      _controller?.dispose();
    } else if (state == AppLifecycleState.resumed) {
      _initializeCamera();
    }
  }

  Future<void> _requestCameraPermission() async {
    var status = await Permission.camera.request();
    if (mounted) {
      if (status.isGranted) {
        _initializeCamera();
      } else {
        setState(() {
          _error = status.isPermanentlyDenied
              ? 'Camera permission permanently denied. Please enable it in settings.'
              : 'Camera permission is required to capture moves.';
        });
      }
    }
  }

  Future<void> _initializeCamera() async {
    try {
      final cameras = await availableCameras();
      if (cameras.isEmpty) {
        setState(() => _error = 'No cameras available');
        return;
      }

      final controller = CameraController(
        cameras.first,
        ResolutionPreset.max,
        enableAudio: false,
      );

      await controller.initialize();

      if (mounted) {
        setState(() {
          _controller = controller;
          _isCameraInitialized = true;
          _error = null;
        });
      }
    } catch (e) {
      setState(() => _error = 'Error initializing camera: $e');
    }
  }

  Future<void> _captureAndAnalyze() async {
    if (_processing ||
        _controller == null ||
        !_controller!.value.isInitialized) {
      return;
    }

    setState(() => _processing = true);

    try {
      // Show processing indicator
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('Processing image...')),
        );
      }

      // Capture image
      final image = await _controller!.takePicture();

      // Get current session details
      final gameState = context.read<GameSessionProvider>();
      final session = gameState.currentSession;

      if (session == null) {
        throw Exception('No active game session');
      }

      // Analyze with Gemini
      final analysis = await _geminiService.analyzeBoardImage(
        session.id,
        image.path,
      );

      if (!mounted) return;

      // Close the processing snackbar
      ScaffoldMessenger.of(context).hideCurrentSnackBar();

      if (analysis['status'] == 'success') {
        List<Map<String, dynamic>> tiles = [];
        String word = '';
        int score = 0;

        print('Analysis response: $analysis'); // Debug log

        if (analysis['type'] == 'initial') {
          // Parse initial board setup
          tiles = (analysis['data']['board'] as List)
              .map((tile) => {
                    'letter': tile['letter'],
                    'row': tile['row'],
                    'col': tile['col'],
                    'points': tile['points'],
                  })
              .toList();

          // For first move
          word = tiles.map((t) => t['letter']).join();
          score = tiles.fold(0, (sum, tile) => sum + (tile['points'] as int));

          // Update board state first
          await gameState.updateBoardState(session.id, tiles);
        } else {
          // Parse delta changes
          tiles = (analysis['data']['newLetters'] as List)
              .map((tile) => {
                    'letter': tile['letter'],
                    'row': tile['row'],
                    'col': tile['col'],
                    'points': tile['points'],
                  })
              .toList();

          word = analysis['data']['word'] as String;
          score = analysis['data']['score'] as int;
        }

        // Show confirmation dialog
        final confirmed = await _showMoveConfirmation(word, score, tiles);

        if (confirmed == true && mounted) {
          // Add move to session
          await gameState.addMove(
            word: word,
            score: score,
            playerId: session.currentPlayerId,
            tiles: tiles,
          );

          if (mounted) {
            Navigator.pop(context);
          }
        }
      } else {
        throw Exception(analysis['message']);
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error: $e'),
            backgroundColor: Colors.red,
          ),
        );
      }
    } finally {
      if (mounted) {
        setState(() => _processing = false);
      }
    }
  }

  Future<bool?> _showMoveConfirmation(
    String word,
    int score,
    List<Map<String, dynamic>> tiles,
  ) {
    return showDialog<bool>(
      context: context,
      barrierDismissible: false,
      builder: (context) => AlertDialog(
        title: const Text('Confirm Move'),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text('Word: $word'),
            const SizedBox(height: 8),
            Text('Score: $score points'),
            if (tiles.isNotEmpty) ...[
              const SizedBox(height: 16),
              const Text('Tiles placed:'),
              const SizedBox(height: 8),
              Wrap(
                spacing: 8,
                children: [
                  for (var tile in tiles)
                    Chip(
                      label: Text('${tile['letter']} (${tile['points']})'),
                    ),
                ],
              ),
            ],
          ],
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context, false),
            child: const Text('Retake'),
          ),
          TextButton(
            onPressed: () => Navigator.pop(context, true),
            child: const Text('Confirm'),
          ),
        ],
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Capture Move'),
      ),
      body: _buildBody(),
    );
  }

  Widget _buildBody() {
    if (_error != null) {
      return Center(
        child: Padding(
          padding: const EdgeInsets.all(16.0),
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              Text(
                _error!,
                textAlign: TextAlign.center,
                style: const TextStyle(color: Colors.red),
              ),
              const SizedBox(height: 16),
              ElevatedButton(
                onPressed: _requestCameraPermission,
                child: const Text('Grant Camera Permission'),
              ),
              const SizedBox(height: 8),
              TextButton(
                onPressed: () => openAppSettings(),
                child: const Text('Open App Settings'),
              ),
            ],
          ),
        ),
      );
    }

    if (!_isCameraInitialized || _controller == null) {
      return const Center(child: CircularProgressIndicator());
    }
    return Stack(
      fit: StackFit.expand,
      children: [
        CameraPreview(_controller!),
        if (_processing)
          Container(
            color: Colors.black54,
            child: const Center(
              child: CircularProgressIndicator(color: Colors.white),
            ),
          ),
        Positioned(
          bottom: 32,
          left: 0,
          right: 0,
          child: Center(
            child: FloatingActionButton(
              onPressed: _processing ? null : _captureAndAnalyze,
              child: _processing
                  ? const SizedBox(
                      width: 24,
                      height: 24,
                      child: CircularProgressIndicator(
                        color: Colors.white,
                        strokeWidth: 2,
                      ),
                    )
                  : const Icon(Icons.camera_alt),
            ),
          ),
        ),
        Positioned(
          bottom: 0,
          left: 0,
          right: 0,
          child: Container(
            color: Colors.black54,
            padding: const EdgeInsets.all(16),
            child: const Text(
              'Position the board within the frame and ensure good lighting',
              style: TextStyle(color: Colors.white),
              textAlign: TextAlign.center,
            ),
          ),
        ),
      ],
    );
  }
}
```\n
\n### src/screens/game_setup_screen.dart\n
```dart
// lib/src/screens/game_setup_screen.dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../providers/game_session_provider.dart';
import 'game_monitoring_screen.dart';

class GameSetupScreen extends StatefulWidget {
  const GameSetupScreen({super.key});

  @override
  State<GameSetupScreen> createState() => _GameSetupScreenState();
}

class _GameSetupScreenState extends State<GameSetupScreen> {
  final _formKey = GlobalKey<FormState>();
  final _player1Controller = TextEditingController();
  final _player2Controller = TextEditingController();
  bool _isProcessing = false;

  @override
  void dispose() {
    _player1Controller.dispose();
    _player2Controller.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('New Game Setup'),
      ),
      body: Padding(
        padding: const EdgeInsets.all(16),
        child: Form(
          key: _formKey,
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.stretch,
            children: [
              TextFormField(
                controller: _player1Controller,
                decoration: const InputDecoration(
                  labelText: 'Player 1 Name',
                  prefixIcon: Icon(Icons.person),
                ),
                validator: (value) {
                  if (value == null || value.trim().isEmpty) {
                    return 'Please enter player 1 name';
                  }
                  return null;
                },
              ),
              const SizedBox(height: 16),
              TextFormField(
                controller: _player2Controller,
                decoration: const InputDecoration(
                  labelText: 'Player 2 Name',
                  prefixIcon: Icon(Icons.person),
                ),
                validator: (value) {
                  if (value == null || value.trim().isEmpty) {
                    return 'Please enter player 2 name';
                  }
                  return null;
                },
              ),
              const SizedBox(height: 32),
              ElevatedButton(
                onPressed: _isProcessing ? null : _startGame,
                style: ElevatedButton.styleFrom(
                  padding: const EdgeInsets.symmetric(vertical: 16),
                ),
                child: _isProcessing
                    ? const CircularProgressIndicator()
                    : const Text('Start Game'),
              ),
              if (context.select((GameSessionProvider p) => p.error) != null)
                Padding(
                  padding: const EdgeInsets.only(top: 16),
                  child: Text(
                    context.read<GameSessionProvider>().error!,
                    style: const TextStyle(color: Colors.red),
                  ),
                ),
            ],
          ),
        ),
      ),
    );
  }

  Future<void> _startGame() async {
    if (!_formKey.currentState!.validate()) return;

    setState(() => _isProcessing = true);

    try {
      await context.read<GameSessionProvider>().createGameSession(
            _player1Controller.text.trim(),
            _player2Controller.text.trim(),
          );

      if (!mounted) return;
      String sessionId = context.read<GameSessionProvider>().currentSession!.id;
      // Navigate to monitoring screen
      Navigator.of(context).pushReplacement(
        MaterialPageRoute(
          builder: (_) =>  GameMonitoringScreen(sessionId: sessionId),
        ),
      );
    } finally {
      if (mounted) {
        setState(() => _isProcessing = false);
      }
    }
  }
}
```\n
\n### src/themes/app_theme.dart\n
```dart
import 'package:flutter/material.dart';

class AppTheme {
  static ThemeData get theme => ThemeData(
    // Theme configuration will go here
  );
}
```\n
\n### src/services/firebase_service.dart\n
```dart
// lib/src/services/firebase_service.dart
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:uuid/uuid.dart';
import '../models/game_session.dart';

class FirebaseService {
  final FirebaseFirestore _firestore = FirebaseFirestore.instanceFor(
    app: FirebaseFirestore.instance.app,
    databaseId: "scrabble",
  );
  final _uuid = const Uuid();

  // Update session QR code
  Future<GameSession> updateSessionQRCode(
    String sessionId,
    String qrCode,
  ) async {
    await _firestore
        .collection('game_sessions')
        .doc(sessionId)
        .update({'qrCode': qrCode});

    final doc =
        await _firestore.collection('game_sessions').doc(sessionId).get();

    return _parseSessionDoc(doc);
  }

  // Update session status
  Future<void> updateSessionStatus(
    String sessionId,
    bool isActive,
  ) async {
    await _firestore
        .collection('game_sessions')
        .doc(sessionId)
        .update({'isActive': isActive});
  }

  // Get session by ID
  Future<GameSession> getSession(String sessionId) async {
    final doc =
        await _firestore.collection('game_sessions').doc(sessionId).get();

    if (!doc.exists) {
      throw Exception('Session not found');
    }

    return _parseSessionDoc(doc);
  }

  // Get active sessions
  Stream<List<GameSession>> getActiveSessions() {
    return _firestore
        .collection('game_sessions')
        .where('isActive', isEqualTo: true)
        .orderBy('startTime', descending: true)
        .snapshots()
        .map((snapshot) {
      return snapshot.docs.map((doc) => _parseSessionDoc(doc)).toList();
    });
  }

// Get real-time board state updates
  Stream<Map<String, dynamic>> getBoardState(String sessionId) {
    return _firestore
        .collection('game_sessions')
        .doc(sessionId)
        .collection('board_state')
        .doc('current')
        .snapshots()
        .map((snapshot) {
      if (!snapshot.exists) {
        return {};
      }
      return snapshot.data() as Map<String, dynamic>;
    });
  }

  // Get real-time session moves
  Stream<List<Map<String, dynamic>>> getSessionMoves(String sessionId) {
    return _firestore
        .collection('game_sessions')
        .doc(sessionId)
        .collection('moves')
        .orderBy('timestamp', descending: false)
        .snapshots()
        .map((snapshot) {
      return snapshot.docs.map((doc) {
        final data = doc.data();
        // Convert Timestamp to DateTime
        if (data['timestamp'] is Timestamp) {
          data['timestamp'] = (data['timestamp'] as Timestamp).toDate();
        }
        return data;
      }).toList();
    });
  }

  // Get real-time player score
  Stream<int> getPlayerScore(String sessionId, String playerId) {
    return _firestore
        .collection('game_sessions')
        .doc(sessionId)
        .collection('moves')
        .where('playerId', isEqualTo: playerId)
        .snapshots()
        .map((snapshot) {
      return snapshot.docs.fold<int>(
        0,
        (sum, doc) => sum + (doc.data()['score'] as int? ?? 0),
      );
    });
  }

  // Update player score (if needed separately from moves)
  Future<void> updatePlayerScore(
      String sessionId, String playerId, int score) async {
    await _firestore.collection('game_sessions').doc(sessionId).update({
      'scores.$playerId': FieldValue.increment(score),
    });
  }

  // Get single move by ID
  Future<Map<String, dynamic>?> getMove(String sessionId, String moveId) async {
    final doc = await _firestore
        .collection('game_sessions')
        .doc(sessionId)
        .collection('moves')
        .doc(moveId)
        .get();

    if (!doc.exists) return null;

    final data = doc.data()!;
    if (data['timestamp'] is Timestamp) {
      data['timestamp'] = (data['timestamp'] as Timestamp).toDate();
    }
    return data;
  }

  // Switch to next player's turn
  Future<void> switchTurn(String sessionId) async {
    final session = await getSession(sessionId);
    final nextPlayerId = session.getNextPlayerId();

    await _firestore
        .collection('game_sessions')
        .doc(sessionId)
        .update({'currentPlayerId': nextPlayerId});
  }

  // Update your createGameSession method to include currentPlayerId
  Future<GameSession> createGameSession({
    required String player1Name,
    required String player2Name,
  }) async {
    final sessionId = _uuid.v4();
    final sessionData = {
      'id': sessionId,
      'player1Name': player1Name,
      'player2Name': player2Name,
      'startTime': FieldValue.serverTimestamp(),
      'isActive': true,
      'currentPlayerId': 'p1', // Start with player 1
      'createdAt': FieldValue.serverTimestamp(),
    };

    await _firestore
        .collection('game_sessions')
        .doc(sessionId)
        .set(sessionData);

    return GameSession(
      id: sessionId,
      player1Name: player1Name,
      player2Name: player2Name,
      startTime: DateTime.now(),
      currentPlayerId: 'p1',
      isActive: true,
    );
  }

  // Update your addMoveToSession method to handle turn switching
  Future<void> addMoveToSession({
    required String sessionId,
    required String word,
    required int score,
    required String playerId,
    required List<Map<String, dynamic>> tiles,
  }) async {
    final batch = _firestore.batch();

    // Add the move
    final moveRef = _firestore
        .collection('game_sessions')
        .doc(sessionId)
        .collection('moves')
        .doc();

    batch.set(moveRef, {
      'word': word,
      'score': score,
      'playerId': playerId,
      'tiles': tiles,
      'timestamp': FieldValue.serverTimestamp(),
    });

    // Switch to next player
    final sessionRef = _firestore.collection('game_sessions').doc(sessionId);

    final session = await getSession(sessionId);
    batch.update(sessionRef, {
      'currentPlayerId': session.getNextPlayerId(),
    });

    await batch.commit();
  }

  Stream<QuerySnapshot> getGameSessions() {
    return _firestore
        .collection('game_sessions')
        .orderBy('startTime', descending: true)
        .snapshots();
  }

  // Delete a session and all its subcollections
  Future<void> deleteSession(String sessionId) async {
    // Delete moves subcollection
    final movesSnapshot = await _firestore
        .collection('game_sessions')
        .doc(sessionId)
        .collection('moves')
        .get();

    final batch = _firestore.batch();

    for (var doc in movesSnapshot.docs) {
      batch.delete(doc.reference);
    }

    // Delete main session document
    batch.delete(_firestore.collection('game_sessions').doc(sessionId));

    await batch.commit();
  }

  // Get remaining letters
  Future<int> getRemainingLetters(String sessionId) async {
    final doc = await _firestore
        .collection('game_sessions')
        .doc(sessionId)
        .collection('game_state')
        .doc('letters')
        .get();

    if (!doc.exists) {
      return 0;
    }

    final data = doc.data() as Map<String, dynamic>;
    return data['remaining'] ?? 0;
  }

  // Update the board state with new tiles
  Future<void> updateBoardState(
      String sessionId, List<Map<String, dynamic>> tiles) async {
    final batch = _firestore.batch();
    final boardRef = _firestore
        .collection('game_sessions')
        .doc(sessionId)
        .collection('board_state')
        .doc('current');

    // Get current board state
    final currentState = await boardRef.get();
    Map<String, dynamic> currentData = currentState.data() ?? {};

    // Update with new tiles
    for (var tile in tiles) {
      String key = '${tile['row']}-${tile['col']}';
      currentData[key] = {
        'letter': tile['letter'],
        'points': tile['points'],
        'playerId': tile['playerId'],
      };
    }

    batch.set(boardRef, currentData, SetOptions(merge: true));
    await batch.commit();
  }

// Update the session with the last move's image path
  Future<void> updateSessionImage(String sessionId, String imagePath) async {
    await _firestore.collection('game_sessions').doc(sessionId).update({
      'lastMoveImage': imagePath,
    });
  }

  GameSession _parseSessionDoc(DocumentSnapshot doc) {
    final data = doc.data() as Map<String, dynamic>;
    final timestamp = data['startTime'] as Timestamp;

    // Get moves from the document if they exist
    List<Move> moves = [];
    if (data['moves'] != null) {
      moves = (data['moves'] as List)
          .map((moveData) => Move.fromJson(moveData))
          .toList();
    }

    return GameSession(
      id: doc.id,
      player1Name: data['player1Name'],
      player2Name: data['player2Name'],
      startTime: timestamp.toDate(),
      qrCode: data['qrCode'],
      isActive: data['isActive'] ?? false,
      currentPlayerId: data['currentPlayerId'] ?? 'p1',
      moves: moves,
    );
  }

  Future<Move?> getLastMove(String sessionId) async {
    try {
      final querySnapshot = await _firestore
          .collection('game_sessions')
          .doc(sessionId)
          .collection('moves')
          .orderBy('timestamp', descending: true)
          .limit(1)
          .get();

      if (querySnapshot.docs.isEmpty) {
        return null;
      }

      return Move.fromJson(querySnapshot.docs.first.data());
    } catch (e) {
      print('Error getting last move: $e');
      return null;
    }
  }
}
```\n
\n### src/services/gemini_service.dart\n
```dart
import 'dart:convert';
import 'dart:io';
import 'package:google_generative_ai/google_generative_ai.dart';
import 'package:firebase_storage/firebase_storage.dart';
import '../config/env_config.dart';
import '../services/firebase_service.dart';

class GeminiService {
  late GenerativeModel _model;
  final FirebaseService _firebaseService = FirebaseService();
  final FirebaseStorage _storage = FirebaseStorage.instance;

  GeminiService() {
    _model = GenerativeModel(
      model: 'gemini-1.5-pro',
      apiKey: 'AIzaSyAMRHzq6_i_jVDUfxOooscv5riCNIxqyXQ',
      generationConfig: GenerationConfig(
        temperature: 0.7,
        topK: 40,
        topP: 0.95,
        maxOutputTokens: 8192,
        responseMimeType: 'text/plain',
      ),
    );
  }

  Future<String> _uploadImageToStorage(String sessionId, String imagePath) async {
    final timestamp = DateTime.now().millisecondsSinceEpoch;
    final fileName = 'moves/${sessionId}_$timestamp.jpg';
    final ref = _storage.ref().child(fileName);
    
    await ref.putFile(File(imagePath));
    return fileName;
  }

  Future<Map<String, dynamic>> analyzeBoardImage(
    String sessionId,
    String imagePath,
  ) async {
    try {
      // Get previous board state and last image
      final boardState = await _firebaseService.getBoardState(sessionId).first;
      final isFirstMove = boardState.isEmpty;

      // Upload current image to Firebase Storage
      final currentImagePath = await _uploadImageToStorage(sessionId, imagePath);
      
      // Read current image bytes
      final currentImageBytes = await File(imagePath).readAsBytes();

      if (isFirstMove) {
        // Handle first move
        final response = await _model.generateContent([
          Content.multi([
            TextPart(_constructInitialBoardPrompt()),
            DataPart('image/jpeg', currentImageBytes),
          ]),
        ]);

        if (response.text == null) {
          throw Exception('Empty response from Gemini');
        }

        return {
          'status': 'success',
          'type': 'initial',
          'data': _parseGeminiResponse(response.text!, true),
          'imagePath': currentImagePath,
        };
      } else {
        // Get previous image
        final lastMove = await _firebaseService.getLastMove(sessionId);
        if (lastMove == null || lastMove.imagePath == null) {
          throw Exception('Previous move image not found');
        }

        // Download previous image
        final prevImageRef = _storage.ref().child(lastMove.imagePath!);
        final prevImageBytes = await prevImageRef.getData();

        if (prevImageBytes == null) {
          throw Exception('Failed to download previous image');
        }

        // Compare images using Gemini
        final response = await _model.generateContent([
          Content.multi([
            TextPart(_constructImageComparisonPrompt(boardState)),
            DataPart('image/jpeg', prevImageBytes),
            DataPart('image/jpeg', currentImageBytes),
          ]),
        ]);

        if (response.text == null) {
          throw Exception('Empty response from Gemini');
        }

        return {
          'status': 'success',
          'type': 'move',
          'data': _parseGeminiResponse(response.text!, false),
          'imagePath': currentImagePath,
        };
      }
    } catch (e) {
      print('Error in analyzeBoardImage: $e');
      return {
        'status': 'error',
        'message': e.toString(),
      };
    }
  }

  String _constructInitialBoardPrompt() {
    return '''
You are analyzing an initial Scrabble board image. Identify all visible letters and their positions.

Return ONLY a JSON object in exactly this format:
{
  "board": [
    {
      "letter": "A",
      "row": 7,
      "col": 7,
      "points": 1
    }
  ]
}

Rules:
- Use 0-based indices (0-14) for rows and columns
- Include ONLY placed letters, ignore empty squares
- All coordinates must be within the 15x15 grid
- Return ONLY the JSON, no explanatory text
''';
  }

  String _constructImageComparisonPrompt(Map<String, dynamic> previousState) {
    return '''
Compare these two Scrabble board images: the first is the previous state, the second is the current state.
Identify ONLY the letters that appear in the second image but not in the first.

Previous board state for reference:
${jsonEncode(previousState)}

Return ONLY a JSON object in exactly this format:
{
  "word": "EXAMPLE",
  "score": 15,
  "newLetters": [
    {
      "letter": "A",
      "row": 7,
      "col": 7,
      "points": 1
    }
  ]
}

Rules:
- Compare the images to find ONLY new letters
- Calculate score including board multipliers
- Return ONLY the JSON, no explanatory text
- Use 0-based indices (0-14) for coordinates
''';
  }

  Map<String, dynamic> _parseGeminiResponse(String response, bool isFirstMove) {
    try {
      String cleanJson = response
          .replaceAll(RegExp(r'```json\n?'), '')
          .replaceAll(RegExp(r'```\n?'), '')
          .trim();

      return jsonDecode(cleanJson);
    } catch (e) {
      throw Exception('Invalid response format: $e');
    }
  }
}```\n
\n### src/services/qr_service.dart\n
```dart
// lib/src/services/qr_service.dart
import 'dart:convert';
import 'package:qr_flutter/qr_flutter.dart';
import 'package:flutter/material.dart';

class QRService {
  // Generate QR code data
  String generateQRCodeData(String sessionId) {
    final data = {
      'sessionId': sessionId,
      'timestamp': DateTime.now().toIso8601String(),
      'type': 'scrabble_game',
    };
    
    return jsonEncode(data);
  }

  // Generate QR code widget
  Widget generateQRCode(String sessionId, {double size = 200}) {
    final data = generateQRCodeData(sessionId);
    
    return QrImageView(
      data: data,
      version: QrVersions.auto,
      size: size,
      backgroundColor: Colors.white,
    );
  }
}

// lib/src/screens/qr_display_screen.dart
class QRDisplayScreen extends StatelessWidget {
  final String sessionId;
  final QRService _qrService = QRService();

  QRDisplayScreen({
    super.key,
    required this.sessionId,
  });

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Connect to Game'),
      ),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Card(
              elevation: 4,
              child: Padding(
                padding: const EdgeInsets.all(16.0),
                child: Column(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    _qrService.generateQRCode(sessionId, size: 250),
                    const SizedBox(height: 16),
                    const Text(
                      'Scan this code with the Companion App',
                      style: TextStyle(fontSize: 16),
                    ),
                    const SizedBox(height: 8),
                    Text(
                      'Session ID: $sessionId',
                      style: const TextStyle(
                        fontSize: 12,
                        color: Colors.grey,
                      ),
                    ),
                  ],
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }
}```\n
\n### src/widgets/board_preview_widget.dart\n
```dart
// lib/src/widgets/board_preview_widget.dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../providers/game_session_provider.dart';
import '../services/firebase_service.dart';

class BoardPreviewWidget extends StatelessWidget {
  const BoardPreviewWidget({super.key});

  @override
  Widget build(BuildContext context) {
    return Card(
      margin: const EdgeInsets.all(16),
      child: Consumer<GameSessionProvider>(
        builder: (context, provider, child) {
          return StreamBuilder<Map<String, dynamic>>(
            stream: FirebaseService().getBoardState(provider.currentSession!.id),
            builder: (context, snapshot) {
              if (snapshot.hasError) {
                return Center(child: Text('Error: ${snapshot.error}'));
              }

              if (!snapshot.hasData) {
                return const Center(child: CircularProgressIndicator());
              }

              final boardState = snapshot.data!;
              return GridView.builder(
                physics: const NeverScrollableScrollPhysics(),
                gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
                  crossAxisCount: 15,
                  childAspectRatio: 1,
                ),
                itemCount: 225, // 15x15 grid
                itemBuilder: (context, index) {
                  final row = index ~/ 15;
                  final col = index % 15;
                  return _buildSquare(context, boardState, row, col);
                },
              );
            },
          );
        },
      ),
    );
  }

  Widget _buildSquare(BuildContext context, Map<String, dynamic> boardState, int row, int col) {
    final squareData = boardState['$row-$col'] as Map<String, dynamic>?;

    return Container(
      decoration: BoxDecoration(
        border: Border.all(color: Colors.black12),
        color: _getSquareColor(squareData?['type'] ?? 'normal'),
      ),
      child: squareData?['letter'] != null
          ? _buildTile(context, squareData!)
          : _buildSquareContent(squareData?['type'] ?? 'normal'),
    );
  }

  Widget _buildTile(BuildContext context, Map<String, dynamic> tileData) {
    return Container(
      margin: const EdgeInsets.all(1),
      decoration: BoxDecoration(
        color: const Color(0xFFF7D698),
        borderRadius: BorderRadius.circular(4),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.2),
            blurRadius: 2,
            offset: const Offset(1, 1),
          ),
        ],
      ),
      child: Stack(
        children: [
          Center(
            child: Text(
              tileData['letter'],
              style: const TextStyle(
                fontSize: 14,
                fontWeight: FontWeight.bold,
              ),
            ),
          ),
          Positioned(
            right: 2,
            bottom: 1,
            child: Text(
              '${tileData['points']}',
              style: const TextStyle(
                fontSize: 8,
                fontWeight: FontWeight.bold,
                color: Colors.black54,
              ),
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildSquareContent(String type) {
    String label = '';
    switch (type) {
      case 'tripleWord':
        label = 'TW';
        break;
      case 'doubleWord':
        label = 'DW';
        break;
      case 'tripleLetter':
        label = 'TL';
        break;
      case 'doubleLetter':
        label = 'DL';
        break;
      case 'center':
        label = 'â˜…';
        break;
      default:
        return const SizedBox();
    }

    return Center(
      child: Text(
        label,
        style: const TextStyle(
          fontSize: 10,
          fontWeight: FontWeight.bold,
          color: Colors.black54,
        ),
      ),
    );
  }

  Color _getSquareColor(String type) {
    switch (type) {
      case 'tripleWord':
        return Colors.red[100]!;
      case 'doubleWord':
        return Colors.pink[50]!;
      case 'tripleLetter':
        return Colors.blue[100]!;
      case 'doubleLetter':
        return Colors.lightBlue[50]!;
      case 'center':
        return Colors.pink[50]!;
      default:
        return Colors.white;
    }
  }
}```\n
\n### src/widgets/move_history_widget.dart\n
```dart
// lib/src/widgets/move_history_widget.dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:intl/intl.dart';
import '../providers/game_session_provider.dart';
import '../services/firebase_service.dart';

class MoveHistoryWidget extends StatelessWidget {
  const MoveHistoryWidget({super.key});

  @override
  Widget build(BuildContext context) {
    return Card(
      margin: const EdgeInsets.all(16),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.stretch,
        children: [
          Container(
            padding: const EdgeInsets.all(16),
            decoration: BoxDecoration(
              border: Border(
                bottom: BorderSide(
                  color: Theme.of(context).dividerColor,
                ),
              ),
            ),
            child: const Text(
              'Move History',
              style: TextStyle(
                fontSize: 18,
                fontWeight: FontWeight.bold,
              ),
            ),
          ),
          Expanded(
            child: _buildMoveList(),
          ),
        ],
      ),
    );
  }

  Widget _buildMoveList() {
    return Consumer<GameSessionProvider>(
      builder: (context, provider, child) {
        return StreamBuilder<List<Map<String, dynamic>>>(
          stream: FirebaseService().getSessionMoves(provider.currentSession!.id),
          builder: (context, snapshot) {
            if (snapshot.hasError) {
              return Center(child: Text('Error: ${snapshot.error}'));
            }

            if (!snapshot.hasData) {
              return const Center(child: CircularProgressIndicator());
            }

            final moves = snapshot.data!;
            if (moves.isEmpty) {
              return const Center(child: Text('No moves yet'));
            }

            return ListView.builder(
              itemCount: moves.length,
              itemBuilder: (context, index) {
                final move = moves[index];
                return _buildMoveItem(context, move, index + 1);
              },
            );
          },
        );
      },
    );
  }

  Widget _buildMoveItem(BuildContext context, Map<String, dynamic> move, int moveNumber) {
    final timestamp = move['timestamp'] as DateTime;
    final isPlayer1 = move['playerId'] == 'p1';
    final provider = context.read<GameSessionProvider>();
    final playerName = isPlayer1 
        ? provider.currentSession!.player1Name 
        : provider.currentSession!.player2Name;

    return ListTile(
      leading: CircleAvatar(
        backgroundColor: isPlayer1 ? Colors.blue[300] : Colors.green[300],
        child: Text(
          move['word'][0],
          style: const TextStyle(color: Colors.white),
        ),
      ),
      title: Text(move['word']),
      subtitle: Text('$playerName - ${move['score']} points'),
      trailing: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        crossAxisAlignment: CrossAxisAlignment.end,
        children: [
          Text(
            '#$moveNumber',
            style: Theme.of(context).textTheme.bodySmall,
          ),
          Text(
            DateFormat.jm().format(timestamp),
            style: Theme.of(context).textTheme.bodySmall,
          ),
        ],
      ),
      onTap: () => _showMoveDetails(context, move),
    );
  }

  void _showMoveDetails(BuildContext context, Map<String, dynamic> move) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: Text('Move #${move['word']}'),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text('Score: ${move['score']} points'),
            const SizedBox(height: 8),
            Text('Player: ${move['playerId'] == 'p1' ? 'Player 1' : 'Player 2'}'),
            const SizedBox(height: 8),
            Text('Time: ${DateFormat.jm().format(move['timestamp'] as DateTime)}'),
            if (move['tiles'] != null) ...[
              const SizedBox(height: 16),
              const Text('Tiles placed:'),
              const SizedBox(height: 8),
              Wrap(
                spacing: 8,
                children: [
                  for (final tile in move['tiles'])
                    Chip(
                      label: Text('${tile['letter']} (${tile['points']})'),
                    ),
                ],
              ),
            ],
          ],
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('Close'),
          ),
        ],
      ),
    );
  }
}```\n
\n### src/widgets/player_info_widget.dart\n
```dart
// lib/src/widgets/player_info_widget.dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../providers/game_session_provider.dart';
import '../services/firebase_service.dart';

class PlayerInfoWidget extends StatelessWidget {
  final String player1Name;
  final String player2Name;

  const PlayerInfoWidget({
    super.key,
    required this.player1Name,
    required this.player2Name,
  });

  @override
  Widget build(BuildContext context) {
    return Card(
      margin: const EdgeInsets.all(16),
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Row(
          children: [
            Expanded(
              child: _buildPlayerInfo(
                context,
                name: player1Name,
                playerId: 'p1',
                color: Colors.blue[300]!,
              ),
            ),
            Container(
              height: 40,
              width: 2,
              color: Colors.grey[300],
            ),
            Expanded(
              child: _buildPlayerInfo(
                context,
                name: player2Name,
                playerId: 'p2',
                color: Colors.green[300]!,
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildPlayerInfo(
    BuildContext context, {
    required String name,
    required String playerId,
    required Color color,
  }) {
    return StreamBuilder<int>(
      stream: FirebaseService().getPlayerScore(
        context.read<GameSessionProvider>().currentSession!.id,
        playerId,
      ),
      builder: (context, snapshot) {
        final score = snapshot.data ?? 0;
        final isCurrentPlayer = context.select(
          (GameSessionProvider p) => p.currentSession?.currentPlayerId == playerId,
        );

        return Container(
          padding: const EdgeInsets.all(8),
          decoration: BoxDecoration(
            borderRadius: BorderRadius.circular(8),
            border: isCurrentPlayer
                ? Border.all(color: color, width: 2)
                : null,
          ),
          child: Column(
            children: [
              Row(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  CircleAvatar(
                    backgroundColor: color,
                    radius: 16,
                    child: Text(
                      name[0],
                      style: const TextStyle(
                        color: Colors.white,
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                  ),
                  const SizedBox(width: 8),
                  Flexible(
                    child: Text(
                      name,
                      style: const TextStyle(
                        fontSize: 16,
                        fontWeight: FontWeight.bold,
                      ),
                      overflow: TextOverflow.ellipsis,
                    ),
                  ),
                ],
              ),
              const SizedBox(height: 8),
              Text(
                'Score: $score',
                style: TextStyle(
                  fontSize: 20,
                  fontWeight: FontWeight.bold,
                  color: color,
                ),
              ),
              if (isCurrentPlayer) ...[
                const SizedBox(height: 4),
                Container(
                  padding: const EdgeInsets.symmetric(
                    horizontal: 8,
                    vertical: 2,
                  ),
                  decoration: BoxDecoration(
                    color: color.withOpacity(0.2),
                    borderRadius: BorderRadius.circular(12),
                  ),
                  child: const Text(
                    'Current Turn',
                    style: TextStyle(fontSize: 12),
                  ),
                ),
              ],
            ],
          ),
        );
      },
    );
  }
}```\n
\n### src/widgets/camera_overlay_widget.dart\n
```dart
```\n
\n## pubspec.yaml\n
```yaml
name: oloodi_scrabble_moderator_app
description: Moderator app for Scrabble game management.
publish_to: 'none'
version: 1.0.0+1

environment:
  sdk: '>=3.0.0 <4.0.0'

dependencies:
  flutter:
    sdk: flutter
  cupertino_icons: ^1.0.2
  provider: ^6.1.1
  firebase_core: ^2.32.0
  cloud_firestore: ^4.13.6
  google_generative_ai: ^0.4.6
  camera: ^0.10.5+9
  qr_flutter: ^4.1.0
  path_provider: ^2.1.5
  uuid: ^4.3.3
  intl: ^0.18.1
  permission_handler: ^11.3.1
  flutter_dotenv: ^5.2.1
  firebase_storage: ^11.6.5
  json_annotation: ^4.9.0

dev_dependencies:
  flutter_test:
    sdk: flutter
  flutter_lints: ^3.0.1
  json_serializable: ^6.9.0
  build_runner: ^2.4.13

flutter:
  uses-material-design: true
  assets:
    - assets/images/
    - assets/icons/
    - .env```
