# Source Code Documentation
\n## Project Structure\n
\n### firebase_options.dart\n
```dart
// File generated by FlutterFire CLI.
// ignore_for_file: type=lint
import 'package:firebase_core/firebase_core.dart' show FirebaseOptions;
import 'package:flutter/foundation.dart'
    show defaultTargetPlatform, kIsWeb, TargetPlatform;

/// Default [FirebaseOptions] for use with your Firebase apps.
///
/// Example:
/// ```dart
/// import 'firebase_options.dart';
/// // ...
/// await Firebase.initializeApp(
///   options: DefaultFirebaseOptions.currentPlatform,
/// );
/// ```
class DefaultFirebaseOptions {
  static FirebaseOptions get currentPlatform {
    if (kIsWeb) {
      return web;
    }
    switch (defaultTargetPlatform) {
      case TargetPlatform.android:
        throw UnsupportedError(
          'DefaultFirebaseOptions have not been configured for android - '
          'you can reconfigure this by running the FlutterFire CLI again.',
        );
      case TargetPlatform.iOS:
        throw UnsupportedError(
          'DefaultFirebaseOptions have not been configured for ios - '
          'you can reconfigure this by running the FlutterFire CLI again.',
        );
      case TargetPlatform.macOS:
        throw UnsupportedError(
          'DefaultFirebaseOptions have not been configured for macos - '
          'you can reconfigure this by running the FlutterFire CLI again.',
        );
      case TargetPlatform.windows:
        throw UnsupportedError(
          'DefaultFirebaseOptions have not been configured for windows - '
          'you can reconfigure this by running the FlutterFire CLI again.',
        );
      case TargetPlatform.linux:
        throw UnsupportedError(
          'DefaultFirebaseOptions have not been configured for linux - '
          'you can reconfigure this by running the FlutterFire CLI again.',
        );
      default:
        throw UnsupportedError(
          'DefaultFirebaseOptions are not supported for this platform.',
        );
    }
  }

  static const FirebaseOptions web = FirebaseOptions(
    apiKey: 'AIzaSyA1mSVhEByfd3i4-MVHI5O48s8QsqORXj8',
    appId: '1:553140087820:web:c6db42b98856c306d51229',
    messagingSenderId: '553140087820',
    projectId: 'learning-box-369917',
    authDomain: 'learning-box-369917.firebaseapp.com',
    storageBucket: 'learning-box-369917.firebasestorage.app',
    measurementId: 'G-KX4ZKD5MPR',
  );
}
```\n
\n### main.dart\n
```dart
// lib/main.dart
import 'package:flutter/material.dart';
import 'package:oloodi_scrabble_end_user_app/src/themes/app_themes.dart';
import 'package:provider/provider.dart';
import 'package:oloodi_scrabble_end_user_app/src/providers/game_state_provider.dart';
import 'package:oloodi_scrabble_end_user_app/src/screens/home_screen.dart';
import 'package:firebase_core/firebase_core.dart';
import 'firebase_options.dart';

void main() async {
  WidgetsFlutterBinding.ensureInitialized();
  await Firebase.initializeApp(
    options: DefaultFirebaseOptions.currentPlatform,
  );
  runApp(const ScrabbleAIApp());
}

class ScrabbleAIApp extends StatelessWidget {
  const ScrabbleAIApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MultiProvider(
      providers: [
        ChangeNotifierProvider(create: (_) => GameStateProvider()),
      ],
      child: MaterialApp(
        title: 'Oloodi Scrabble Companion',
        theme: AppTheme.theme,
        debugShowCheckedModeBanner: false, // Remove debug banner
        home: const HomeScreen(),
      ),
    );
  }
}
```\n
\n### src/providers/game_state_provider.dart\n
```dart
// lib/providers/game_state_provider.dart
import 'dart:async';
import 'package:flutter/material.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:oloodi_scrabble_end_user_app/src/service/firebase_service.dart';
import '../models/board_square.dart';
import '../models/move.dart';
import '../models/tile.dart';
import '../models/player.dart';

class GameStateProvider with ChangeNotifier {
  // Services
  final FirebaseService _firebaseService = FirebaseService();

  // Game state
  List<List<BoardSquare>> _board = [];
  List<Move> _moves = [];
  List<Player> _players = [];
  String? _currentPlayerId;
  bool _isGameOver = false;
  String? _gameId;

  // Subscriptions
  StreamSubscription? _gameSubscription;
  StreamSubscription? _movesSubscription;

  static const Map<String, int> _initialLetterDistribution = {
    'A': 9, 'B': 2, 'C': 2, 'D': 3, 'E': 15,
    'F': 2, 'G': 2, 'H': 2, 'I': 8, 'J': 1,
    'K': 1, 'L': 5, 'M': 3, 'N': 6, 'O': 6,
    'P': 2, 'Q': 1, 'R': 6, 'S': 6, 'T': 6,
    'U': 6, 'V': 2, 'W': 1, 'X': 1, 'Y': 1,
    'Z': 1, '*': 2, // '*' represents blank/joker tiles
  };

  Map<String, int> _remainingLetters = Map.from(_initialLetterDistribution);

  // Constructor
  GameStateProvider() {
    _initializeBoard();
  }

  // Initialize empty board
  void _initializeBoard() {
    _board = List.generate(15, (row) {
      return List.generate(15, (col) {
        return BoardSquare(
          row: row,
          col: col,
          type: _getSquareType(row, col),
        );
      });
    });
    notifyListeners();
  }

  // Initialize game with QR code data
  Future<void> initializeGame(String gameId) async {
    try {
      _gameId = gameId;

      // Listen to game document for player information and game status
      _gameSubscription =
          _firebaseService.listenToGame(gameId).listen((snapshot) {
        final gameData = snapshot.data() as Map<String, dynamic>;
        _updateGameInfo(gameData);
      });

      // Listen to moves collection
      _movesSubscription = _firebaseService.listenToMoves().listen((snapshot) {
        for (var change in snapshot.docChanges) {
          if (change.type == DocumentChangeType.added) {
            final moveData = change.doc.data() as Map<String, dynamic>;
            final move = Move.fromJson(moveData);
            _addMove(move);
          }
        }
      });

      notifyListeners();
    } catch (e) {
      print('Error initializing game: $e');
      rethrow;
    }
  }

  // Update game information from Firebase
  void _updateGameInfo(Map<String, dynamic> gameData) {
    _players = [
      Player(
        id: 'p1',
        displayName: gameData['player1Name'],
        color: Color(gameData['player1Color']),
        imagePath: gameData['player1Image'],
      ),
      Player(
        id: 'p2',
        displayName: gameData['player2Name'],
        color: Color(gameData['player2Color']),
        imagePath: gameData['player2Image'],
      ),
    ];

    _currentPlayerId = gameData['currentPlayerId'];
    _isGameOver = gameData['isGameOver'] ?? false;

    // Update remaining letters if provided in gameData
    if (gameData.containsKey('remainingLetters')) {
      _remainingLetters = Map<String, int>.from(gameData['remainingLetters']);
    }

    notifyListeners();
  }

  // Get square type for board initialization
  SquareType _getSquareType(int row, int col) {
    // Center square - acts as Double Word Score
    if (row == 7 && col == 7) {
      return SquareType.doubleWord;
    }

    // Triple Word Score
    if ((row == 0 || row == 14) && (col == 0 || col == 7 || col == 14) ||
        (row == 7 && (col == 0 || col == 14))) {
      return SquareType.tripleWord;
    }

    // Double Word Score
    if (row == col || row + col == 14) {
      if (row >= 1 && row <= 5 || row >= 9 && row <= 13) {
        return SquareType.doubleWord;
      }
    }

    // Triple Letter Score
    if ((row == 1 || row == 13) && (col == 5 || col == 9) ||
        (row == 5 || row == 9) &&
            (col == 1 || col == 5 || col == 9 || col == 13)) {
      return SquareType.tripleLetter;
    }

    // Double Letter Score
    if ((row == 3 || row == 11) && (col == 0 || col == 7 || col == 14) ||
        (row == 6 || row == 8) &&
            (col == 2 || col == 6 || col == 8 || col == 12) ||
        (row == 0 || row == 7 || row == 14) && (col == 3 || col == 11)) {
      return SquareType.doubleLetter;
    }

    return SquareType.normal;
  }

  // Get moves for a specific player
  List<Move> getMovesByPlayer(String playerId) {
    return _moves.where((move) => move.playerId == playerId).toList();
  }

  // Calculate score for a specific player
  int getPlayerScore(String playerId) {
    return _moves
        .where((move) => move.playerId == playerId)
        .fold(0, (sum, move) => sum + move.score);
  }

  // Get current player
  Player getCurrentPlayer() {
    return _players.firstWhere(
      (player) => player.id == _currentPlayerId,
      orElse: () => _players.first,
    );
  }

  // Check if it's a specific player's turn
  bool isCurrentPlayer(String playerId) {
    return playerId == _currentPlayerId;
  }

  // Get adjacent tiles for a position
  List<Tile?> getAdjacentTiles(int row, int col) {
    List<Tile?> adjacentTiles = [];
    final directions = [(-1, 0), (1, 0), (0, -1), (0, 1)];

    for (var (dRow, dCol) in directions) {
      final newRow = row + dRow;
      final newCol = col + dCol;

      if (newRow >= 0 && newRow < 15 && newCol >= 0 && newCol < 15) {
        adjacentTiles.add(_board[newRow][newCol].tile);
      }
    }

    return adjacentTiles;
  }

  // Cleanup
  @override
  void dispose() {
    _gameSubscription?.cancel();
    _movesSubscription?.cancel();
    super.dispose();
  }

  // Getters
  List<List<BoardSquare>> get board => _board;
  List<Move> get moves => _moves;
  List<Player> get players => _players;
  String? get currentPlayerId => _currentPlayerId;
  bool get isGameOver => _isGameOver;
  Move? get lastMove => _moves.isNotEmpty ? _moves.last : null;

  // Get current game statistics
  Map<String, int> getGameStats() {
    return {
      'totalMoves': _moves.length,
      'player1Score': getPlayerScore('p1'),
      'player2Score': getPlayerScore('p2'),
    };
  }

  // Fetch current state from Firebase and rebuild board
  Future<void> updateBoard() async {
    if (_gameId == null) {
      throw Exception('No active game session');
    }

    try {
      // Get all moves from Firebase in order
      final movesSnapshot = await _firebaseService.getAllMoves(_gameId!);

      // Clear current board
      _initializeBoard();
      _moves.clear();

      // Reapply all moves in order
      for (var doc in movesSnapshot.docs) {
        final moveData = doc.data() as Map<String, dynamic>;
        final move = Move.fromJson(moveData);
        _addMove(move);
      }

      notifyListeners();
    } catch (e) {
      print('Error updating board: $e');
      rethrow;
    }
  }

  // This will be implemented later to create new game session
  Future<void> restartGame() async {
    // For now, just throw not implemented
    throw UnimplementedError(
        'Restart game will be implemented in future version');

    // Future implementation will look something like this:
    /*
    if (_gameId == null) {
      throw Exception('No active game session');
    }

    try {
      // Create new game session in Firebase
      await _firebaseService.createNewSession(_gameId!);
      
      // Reset local state
      _initializeBoard();
      _moves.clear();
      _isGameOver = false;
      
      notifyListeners();
    } catch (e) {
      print('Error restarting game: $e');
      rethrow;
    }
    */
  }

  // Helper method to properly add moves to the board
  void _addMove(Move move) {
    _moves.add(move);

    // Update remaining letters based on the move
    for (var tile in move.tiles) {
      if (_remainingLetters.containsKey(tile.letter)) {
        _remainingLetters[tile.letter] = _remainingLetters[tile.letter]! - 1;
      }
    }

    // Place tiles on board
    for (var tile in move.tiles) {
      _board[tile.row][tile.col].tile = Tile(
        letter: tile.letter,
        points: tile.points,
        playerId: move.playerId,
        isNew: true,
      );
    }

    notifyListeners();

    // Reset the "new" flag after animation
    Future.delayed(const Duration(milliseconds: 800), () {
      for (var tile in move.tiles) {
        if (_board[tile.row][tile.col].tile != null) {
          _board[tile.row][tile.col].tile!.isNew = false;
        }
      }
      notifyListeners();
    });
  }

  // Add getter for remainingLetters
  int get remainingLetters {
    return _remainingLetters.values.fold(0, (sum, count) => sum + count);
  }

  // Optional: Add getter for detailed letter distribution
  Map<String, int> get letterDistribution =>
      Map.unmodifiable(_remainingLetters);
}
```\n
\n### src/models/tile.dart\n
```dart
class Tile {
  final String letter;
  final int points;
  final String playerId;
  bool isNew;

  Tile({
    required this.letter,
    required this.points,
    required this.playerId,
    this.isNew = false,
  });
}
```\n
\n### src/models/move.g.dart\n
```dart
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'move.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

Move _$MoveFromJson(Map<String, dynamic> json) => Move(
      word: json['word'] as String,
      score: (json['score'] as num).toInt(),
      tiles: (json['tiles'] as List<dynamic>)
          .map((e) => PlacedTile.fromJson(e as Map<String, dynamic>))
          .toList(),
      playerId: json['playerId'] as String,
      timestamp: DateTime.parse(json['timestamp'] as String),
    );

Map<String, dynamic> _$MoveToJson(Move instance) => <String, dynamic>{
      'word': instance.word,
      'score': instance.score,
      'tiles': instance.tiles,
      'playerId': instance.playerId,
      'timestamp': instance.timestamp.toIso8601String(),
    };

PlacedTile _$PlacedTileFromJson(Map<String, dynamic> json) => PlacedTile(
      letter: json['letter'] as String,
      row: (json['row'] as num).toInt(),
      col: (json['col'] as num).toInt(),
      points: (json['points'] as num).toInt(),
    );

Map<String, dynamic> _$PlacedTileToJson(PlacedTile instance) =>
    <String, dynamic>{
      'letter': instance.letter,
      'row': instance.row,
      'col': instance.col,
      'points': instance.points,
    };
```\n
\n### src/models/player.dart\n
```dart
import 'package:flutter/material.dart';

class Player {
  final String id;
  final String displayName;
  final Color color;
  final String imagePath;

  const Player({
    required this.id,
    required this.displayName,
    required this.color,
    required this.imagePath,
  });
}
```\n
\n### src/models/board.dart\n
```dart
import 'package:oloodi_scrabble_end_user_app/src/models/tile.dart';

class Board {
  static const int boardSize = 15;
  final List<List<Tile?>> tiles;
  
  Board() : tiles = List.generate(
    boardSize,
    (_) => List.generate(boardSize, (_) => null)
  );
  
  bool isValidPlacement(int row, int col) {
    if (row < 0 || row >= boardSize || col < 0 || col >= boardSize) {
      return false;
    }
    return tiles[row][col] == null;
  }
  
  // Additional board logic will go here
}```\n
\n### src/models/board_square.dart\n
```dart
import 'package:flutter/material.dart';
import 'package:oloodi_scrabble_end_user_app/src/models/tile.dart';

class BoardSquare {
  final int row;
  final int col;
  final SquareType type;
  Tile? tile;

  BoardSquare({
    required this.row,
    required this.col,
    required this.type,
    this.tile,
  });
}

// Add this to your models/board_square.dart or where your SquareType enum is defined
enum SquareType {
  normal,
  doubleLetter, // Light blue - DL
  tripleLetter, // Dark blue - TL
  doubleWord, // Pink - DW
  tripleWord, // Red - TW
  center // Center square (acts as DW)
}

// Add this method to MockGameService
SquareType getBoardSquareType(int row, int col) {
  // Center square
  if (row == 7 && col == 7) {
    return SquareType.center;
  }

  // Triple Word Score (Red)
  if ((row == 0 || row == 14) &&
          (col == 0 || col == 7 || col == 14) || // Corners and middle edges
      (row == 7 && (col == 0 || col == 14))) {
    // Middle row edges
    return SquareType.tripleWord;
  }

  // Double Word Score (Pink)
  if (row == col || row + col == 14) {
    // Diagonals
    if (row >= 1 && row <= 5 || row >= 9 && row <= 13) {
      // Excluding center and edges
      return SquareType.doubleWord;
    }
  }

  // Triple Letter Score (Dark Blue)
  if ((row == 1 || row == 13) && (col == 5 || col == 9) || // Near top/bottom
      (row == 5 || row == 9) &&
          (col == 1 || col == 5 || col == 9 || col == 13)) {
    // Middle area
    return SquareType.tripleLetter;
  }

  // Double Letter Score (Light Blue)
  if ((row == 3 || row == 11) &&
          (col == 0 || col == 7 || col == 14) || // Top/bottom edges
      (row == 6 || row == 8) &&
          (col == 2 || col == 6 || col == 8 || col == 12) || // Middle area
      (row == 0 || row == 7 || row == 14) &&
          (col == 3 || col == 11) || // Left/right edges
      (row == 2 || row == 12) && (col == 6 || col == 8)) {
    // Additional DL squares
    return SquareType.doubleLetter;
  }

  // Normal square
  return SquareType.normal;
}

// Optional: Helper method to get a description of the square
String getSquareDescription(SquareType type) {
  switch (type) {
    case SquareType.normal:
      return '';
    case SquareType.doubleLetter:
      return 'DL';
    case SquareType.tripleLetter:
      return 'TL';
    case SquareType.doubleWord:
      return 'DW';
    case SquareType.tripleWord:
      return 'TW';
    case SquareType.center:
      return '★';
  }
}

// Optional: Helper method to get square color
Color getSquareColor(SquareType type) {
  switch (type) {
    case SquareType.normal:
      return Colors.white;
    case SquareType.doubleLetter:
      return Colors.lightBlue[50]!; // Light blue
    case SquareType.tripleLetter:
      return Colors.blue[100]!; // Dark blue
    case SquareType.doubleWord:
      return Colors.pink[50]!; // Pink
    case SquareType.tripleWord:
      return Colors.red[100]!; // Red
    case SquareType.center:
      return Colors.pink[50]!; // Same as DW
  }
}
```\n
\n### src/models/move.dart\n
```dart
import 'package:json_annotation/json_annotation.dart';

part 'move.g.dart';

@JsonSerializable()
class Move {
  final String word;
  final int score;
  final List<PlacedTile> tiles;
  final String playerId;
  final DateTime timestamp;

  Move({
    required this.word,
    required this.score,
    required this.tiles,
    required this.playerId,
    required this.timestamp,
  });

  factory Move.fromJson(Map<String, dynamic> json) => _$MoveFromJson(json);
  Map<String, dynamic> toJson() => _$MoveToJson(this);
}

@JsonSerializable()
class PlacedTile {
  final String letter;
  final int row;
  final int col;
  final int points;

  PlacedTile({
    required this.letter,
    required this.row,
    required this.col,
    required this.points,
  });

  factory PlacedTile.fromJson(Map<String, dynamic> json) => _$PlacedTileFromJson(json);
  Map<String, dynamic> toJson() => _$PlacedTileToJson(this);
}
```\n
\n### src/screens/home_screen.dart\n
```dart
import 'package:flutter/material.dart';
import 'package:oloodi_scrabble_end_user_app/src/models/move.dart';
import 'package:oloodi_scrabble_end_user_app/src/providers/game_state_provider.dart';
import 'package:oloodi_scrabble_end_user_app/src/themes/app_themes.dart';
import 'package:oloodi_scrabble_end_user_app/src/widgets/board_widget.dart';
import 'package:oloodi_scrabble_end_user_app/src/widgets/player_score_card.dart';
import 'package:provider/provider.dart';

import '../widgets/move_history_panel.dart';

class HomeScreen extends StatefulWidget {
  const HomeScreen({super.key});

  @override
  State<HomeScreen> createState() => _HomeScreenState();
}

class _HomeScreenState extends State<HomeScreen> {
  bool _showHistory = false;
  bool _showChat = false;

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: Row(
        children: [
          // Left Sidebar
          Container(
            width: 250,
            decoration: BoxDecoration(
              color: AppTheme.primaryColor,
              boxShadow: [
                BoxShadow(
                  color: Colors.black.withOpacity(0.1),
                  blurRadius: 5,
                  offset: const Offset(3, 0),
                ),
              ],
            ),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                // App Title
                Padding(
                  padding: const EdgeInsets.all(16.0),
                  child: Row(
                    children: [
                      Image.asset(
                        'assets/images/app_icon.png', // Add your app icon
                        width: 32,
                        height: 32,
                        errorBuilder: (context, error, stackTrace) =>
                            const Icon(
                          Icons.sports_esports,
                          size: 32,
                          color: Colors.white,
                        ),
                      ),
                      const SizedBox(width: 12),
                      const Text(
                        'Oloodi Scrabble\nAI Companion',
                        style: TextStyle(
                          color: Colors.white,
                          fontSize: 20,
                          fontWeight: FontWeight.bold,
                          height: 1.2,
                        ),
                      ),
                    ],
                  ),
                ),
                const Divider(color: Colors.white24),

                // Player Cards
                Padding(
                  padding: const EdgeInsets.symmetric(horizontal: 16.0),
                  child: _buildPlayerCards(),
                ),

                const Spacer(),

                // Action Buttons
                _buildActionButtons(),

                const SizedBox(height: 16),
              ],
            ),
          ),

          // Main Content Area
          Expanded(
            child: Stack(
              children: [
                // Board
                const Center(
                  child: BoardWidget(),
                ),

                // Move History Panel
                if (_showHistory)
                  Positioned(
                    right: 0,
                    top: 0,
                    bottom: 0,
                    width: 300,
                    child: Card(
                      margin: EdgeInsets.zero,
                      shape: const RoundedRectangleBorder(
                        borderRadius:
                            BorderRadius.horizontal(left: Radius.circular(12)),
                      ),
                      child: const MoveHistoryPanel(),
                    ),
                  ),

                // Chat Overlay
                if (_showChat) _buildChatOverlay(),
              ],
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildPlayerCards() {
    return Consumer<GameStateProvider>(
      builder: (context, gameState, child) {
        return Column(
          children: [
            for (final player in gameState.players) ...[
              PlayerScoreCard(
                player: player,
                score: gameState.getPlayerScore(player.id),
                isCurrentPlayer: player.id == gameState.currentPlayerId,
              ),
              const SizedBox(height: 12),
            ],
          ],
        );
      },
    );
  }

  Widget _buildActionButtons() {
    return Consumer<GameStateProvider>(
      builder: (context, gameState, child) {
        return Column(
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            const Divider(color: Colors.white24),
            _buildActionButton(
                icon: Icons.update,
                label: 'Update Board',
                onPressed: gameState.isGameOver
                    ? null
                    : () async {
                        // To sync board state
                        try {
                          await gameState.updateBoard();
                        } catch (e) {
                          // Handle error
                        }
                      }),
            _buildActionButton(
              icon: _showHistory ? Icons.history_toggle_off : Icons.history,
              label: 'Move History',
              isActive: _showHistory,
              onPressed: () {
                setState(() {
                  _showHistory = !_showHistory;
                });
              },
            ),
            _buildActionButton(
              icon: _showChat ? Icons.chat_bubble : Icons.chat_bubble_outline,
              label: 'Chat',
              isActive: _showChat,
              onPressed: () {
                setState(() {
                  _showChat = !_showChat;
                });
              },
            ),
            _buildActionButton(
              icon: Icons.lightbulb_outline,
              label: 'Explain Last Move',
              onPressed: gameState.lastMove != null
                  ? () => _showMoveExplanation(gameState.lastMove!)
                  : null,
            ),
            _buildActionButton(
                icon: Icons.refresh,
                label: 'Restart Game',
                onPressed: () async {
                  // For future restart functionality
                  try {
                    await gameState.restartGame();
                  } catch (e) {
                    if (e is UnimplementedError) {
                      // Show "Coming soon" message
                    } else {
                      // Handle other errors
                    }
                  }
                }),
          ],
        );
      },
    );
  }

  Widget _buildActionButton({
    required IconData icon,
    required String label,
    required VoidCallback? onPressed,
    bool isActive = false,
  }) {
    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 4.0),
      child: TextButton.icon(
        icon: Icon(
          icon,
          color: isActive ? AppTheme.accentColor : Colors.white,
        ),
        label: Text(
          label,
          style: TextStyle(
            color: isActive ? AppTheme.accentColor : Colors.white,
          ),
        ),
        onPressed: onPressed,
        style: TextButton.styleFrom(
          alignment: Alignment.centerLeft,
          padding: const EdgeInsets.symmetric(
            horizontal: 12,
            vertical: 16,
          ),
        ),
      ),
    );
  }

  Widget _buildChatOverlay() {
    return Positioned(
      right: 16,
      bottom: 16,
      width: 300,
      height: 400,
      child: Card(
        elevation: 8,
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(12),
        ),
        child: Column(
          children: [
            // Chat header
            Container(
              padding: const EdgeInsets.all(8),
              decoration: BoxDecoration(
                color: AppTheme.primaryColor,
                borderRadius: const BorderRadius.vertical(
                  top: Radius.circular(12),
                ),
              ),
              child: Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: [
                  const Text(
                    'Game Assistant',
                    style: TextStyle(
                      color: Colors.white,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                  IconButton(
                    icon: const Icon(Icons.close, color: Colors.white),
                    onPressed: () {
                      setState(() {
                        _showChat = false;
                      });
                    },
                  ),
                ],
              ),
            ),
            // Chat messages area
            const Expanded(
              child: Padding(
                padding: EdgeInsets.all(8.0),
                child: Center(
                  child: Text('Chat functionality coming soon...'),
                ),
              ),
            ),
            // Input area
            Padding(
              padding: const EdgeInsets.all(8.0),
              child: Row(
                children: [
                  IconButton(
                    icon: const Icon(Icons.mic),
                    onPressed: () {
                      // Implement voice input
                    },
                  ),
                  const Expanded(
                    child: TextField(
                      decoration: InputDecoration(
                        hintText: 'Type your message...',
                        border: OutlineInputBorder(),
                        contentPadding: EdgeInsets.symmetric(
                          horizontal: 12,
                          vertical: 8,
                        ),
                      ),
                    ),
                  ),
                  IconButton(
                    icon: const Icon(Icons.send),
                    onPressed: () {
                      // Send message
                    },
                  ),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }

  void _showMoveExplanation(Move lastMove) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: Text('${lastMove.word} (${lastMove.score} points)'),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text('Player: ${lastMove.playerId}'),
            const SizedBox(height: 8),
            const Text('Explanation coming soon...'),
          ],
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('Close'),
          ),
        ],
      ),
    );
  }
}
```\n
\n### src/service/camera_service.dart\n
```dart
import 'package:camera/camera.dart';
import 'package:path_provider/path_provider.dart';

class CameraService {
  CameraController? _controller;
  bool _isInitialized = false;

  Future<void> initialize() async {
    final cameras = await availableCameras();
    if (cameras.isEmpty) throw Exception('No cameras available');
    
    _controller = CameraController(
      cameras.first,
      ResolutionPreset.high,
      enableAudio: false,
    );

    await _controller!.initialize();
    _isInitialized = true;
  }

  Future<String> captureImage() async {
    if (!_isInitialized) throw Exception('Camera not initialized');
    
    final XFile image = await _controller!.takePicture();
    final directory = await getTemporaryDirectory();
    final String filePath = '${directory.path}/${DateTime.now().toIso8601String()}.jpg';
    
    await image.saveTo(filePath);
    return filePath;
  }

  void dispose() {
    _controller?.dispose();
    _isInitialized = false;
  }

  bool get isInitialized => _isInitialized;
  CameraController? get controller => _controller;
}```\n
\n### src/service/firebase_service.dart\n
```dart
import 'package:cloud_firestore/cloud_firestore.dart';
import '../models/move.dart';
import '../models/player.dart';

class FirebaseService {
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;
  String? _gameId;

  // Listen to game updates
  Stream<DocumentSnapshot> listenToGame(String gameId) {
    _gameId = gameId;
    return _firestore.collection('games').doc(gameId).snapshots();
  }

  // Listen to moves
  Stream<QuerySnapshot> listenToMoves() {
    if (_gameId == null) throw Exception('Game ID not set');
    return _firestore
        .collection('games')
        .doc(_gameId)
        .collection('moves')
        .orderBy('timestamp', descending: false)
        .snapshots();
  }

  // Get player information
  Future<List<Player>> getPlayers() async {
    if (_gameId == null) throw Exception('Game ID not set');
    final gameDoc = await _firestore.collection('games').doc(_gameId).get();
    final data = gameDoc.data() as Map<String, dynamic>;

    return [
      Player(
        id: 'p1',
        displayName: data['player1Name'],
        color: data['player1Color'],
        imagePath: data['player1Image'],
      ),
      Player(
        id: 'p2',
        displayName: data['player2Name'],
        color: data['player2Color'],
        imagePath: data['player2Image'],
      ),
    ];
  }

  Future<QuerySnapshot> getAllMoves(String gameId) async {
    return await _firestore
        .collection('games')
        .doc(gameId)
        .collection('moves')
        .orderBy('timestamp', descending: false)
        .get();
  }
}
```\n
\n### src/service/gemini_service.dart\n
```dart
import 'package:google_generative_ai/google_generative_ai.dart';
import 'dart:io';

class GeminiService {
  static const String _apiKey =
      'YOUR_API_KEY_HERE'; // Replace with actual API key
  late GenerativeModel _model;

  GeminiService() {
    _model = GenerativeModel(
      model: 'gemini-pro-vision',
      apiKey: _apiKey,
    );
  }

  Future<Map<String, dynamic>> analyzeBoardImage(String imagePath) async {
    try {
      final imageBytes = await File(imagePath).readAsBytes();
      final prompt = '''
        Analyze this Scrabble board image and provide:
        1. All visible words on the board
        2. Position of each word (row and column coordinates)
        3. Score for each word based on letter values and multipliers
        Format the response as JSON with the following structure:
        {
          "words": [
            {
              "word": "string",
              "start": {"row": int, "col": int},
              "direction": "horizontal|vertical",
              "score": int
            }
          ]
        }
      ''';

      final response = await _model.generateContent([
        Content.text(prompt),
        // Content.image(imageBytes),
      ]);

      final jsonResponse = response.text;
      // Parse and validate JSON response
      // Implementation needed

      return {'status': 'success', 'data': jsonResponse};
    } catch (e) {
      return {'status': 'error', 'message': e.toString()};
    }
  }

  Future<String> explainMove(String word, List<String> definitions) async {
    try {
      final prompt = '''
        Explain the Scrabble move for the word "$word":
        1. Word meaning and usage
        2. Strategic value in Scrabble
        3. Alternative words possible with same letters
      ''';

      final response = await _model.generateContent([
        Content.text(prompt),
      ]);

      return response.text ?? '';
    } catch (e) {
      return 'Failed to generate move explanation: ${e.toString()}';
    }
  }
}
```\n
\n### src/service/mock_game_service.dart\n
```dart
// lib/services/mock_game_service.dart
import 'dart:math';

import 'package:oloodi_scrabble_end_user_app/src/models/board_square.dart';
import 'package:oloodi_scrabble_end_user_app/src/models/move.dart';

class MockGameService {
  // Official French Scrabble distribution (102 tiles including 2 blank/joker)
  static final Map<String, int> _initialLetterBag = {
    'A': 9, 'B': 2, 'C': 2, 'D': 3, 'E': 15,
    'F': 2, 'G': 2, 'H': 2, 'I': 8, 'J': 1,
    'K': 1, 'L': 5, 'M': 3, 'N': 6, 'O': 6,
    'P': 2, 'Q': 1, 'R': 6, 'S': 6, 'T': 6,
    'U': 6, 'V': 2, 'W': 1, 'X': 1, 'Y': 1,
    'Z': 1, '*': 2, // '*' represents blank/joker tiles
  };

  // Official French Scrabble points
  static final Map<String, int> letterPoints = {
    'A': 1, 'B': 3, 'C': 3, 'D': 2, 'E': 1,
    'F': 4, 'G': 2, 'H': 4, 'I': 1, 'J': 8,
    'K': 10, 'L': 1, 'M': 2, 'N': 1, 'O': 1,
    'P': 3, 'Q': 8, 'R': 1, 'S': 1, 'T': 1,
    'U': 1, 'V': 4, 'W': 10, 'X': 10, 'Y': 10,
    'Z': 10, '*': 0, // Blanks worth 0 points
  };

  static Map<String, int> _remainingLetters = Map.from(_initialLetterBag);
  static List<List<String?>> _boardState =
      List.generate(15, (_) => List.generate(15, (_) => null));
  static int _consecutivePasses = 0;

  static void resetGame() {
    _remainingLetters = Map.from(_initialLetterBag);
    _boardState = List.generate(15, (_) => List.generate(15, (_) => null));
    _consecutivePasses = 0;
  }

  static int getRemainingLettersCount() {
    return _remainingLetters.values.fold(0, (sum, count) => sum + count);
  }

  static bool isGameOver() {
    // Game ends if:
    // 1. No more letters in bag and a player has used all their letters
    // 2. Three consecutive passes by all players
    // 3. No more valid moves possible and insufficient letters to exchange
    return getRemainingLettersCount() == 0 || _consecutivePasses >= 3;
  }

  static bool _isValidWordPlacement(
      String word, int row, int col, bool isHorizontal, bool isFirstMove) {
    // First move must cross center square
    if (isFirstMove) {
      bool crossesCenter = false;
      for (int i = 0; i < word.length; i++) {
        final currentRow = isHorizontal ? row : row + i;
        final currentCol = isHorizontal ? col + i : col;
        if (currentRow == 7 && currentCol == 7) {
          crossesCenter = true;
          break;
        }
      }
      if (!crossesCenter) return false;
    }

    // Check board boundaries
    if (isHorizontal) {
      if (col + word.length > 15) return false;
    } else {
      if (row + word.length > 15) return false;
    }

    bool connectsToExisting = false;

    // Check each position
    for (int i = 0; i < word.length; i++) {
      final currentRow = isHorizontal ? row : row + i;
      final currentCol = isHorizontal ? col + i : col;

      // Check if current position has a letter
      if (_boardState[currentRow][currentCol] != null) {
        if (_boardState[currentRow][currentCol] != word[i]) {
          return false; // Conflict with existing letter
        }
        connectsToExisting = true;
      }

      // Check adjacent positions
      if (!isFirstMove) {
        if (_hasAdjacentTiles(currentRow, currentCol)) {
          connectsToExisting = true;
        }
      }
    }

    return isFirstMove || connectsToExisting;
  }

  static bool _hasAdjacentTiles(int row, int col) {
    final directions = [(-1, 0), (1, 0), (0, -1), (0, 1)];

    for (var (dRow, dCol) in directions) {
      final newRow = row + dRow;
      final newCol = col + dCol;

      if (newRow >= 0 && newRow < 15 && newCol >= 0 && newCol < 15) {
        if (_boardState[newRow][newCol] != null) {
          return true;
        }
      }
    }

    return false;
  }

  static List<String> _getAvailableLetters() {
    List<String> available = [];
    _remainingLetters.forEach((letter, count) {
      for (int i = 0; i < count; i++) {
        available.add(letter);
      }
    });
    return available;
  }

  static void _removeLettersFromBag(String word) {
    for (var letter in word.split('')) {
      if (_remainingLetters.containsKey(letter) &&
          _remainingLetters[letter]! > 0) {
        _remainingLetters[letter] = _remainingLetters[letter]! - 1;
      }
    }
  }

  static List<Move> generateSampleMoves() {
    resetGame();
    final moves = <Move>[];

    // Start with a valid first move
    final random = Random();
    final firstMoveIndex = random.nextInt(_validFirstMoves.length);
    final (word, tiles) = _validFirstMoves[firstMoveIndex];

    final firstMove = Move(
      word: word,
      score: calculateWordScore(tiles, true),
      playerId: 'p1',
      timestamp: DateTime.now().subtract(const Duration(minutes: 10)),
      tiles: tiles,
    );

    moves.add(firstMove);
    _updateBoardState(firstMove);
    _removeLettersFromBag(word);

    return moves;
  }

  static void _updateBoardState(Move move) {
    for (var tile in move.tiles) {
      _boardState[tile.row][tile.col] = tile.letter;
    }
  }

  // Sample valid French words for simulation
  static final List<String> _validWords = [
    "CADEAU",
    "TABLEAU",
    "MAISON",
    "JARDIN",
    "VOITURE",
    "ÉCOLE",
    "RAPIDE",
    "CHEVAL",
    "MUSIQUE",
    "FLEUR",
    "SOLEIL",
    "PORTE",
    "TABLE",
    "LIVRE",
    "ARBRE",
    "CHAT",
    "CHIEN",
    "OISEAU",
    "POISSON",
    "FRUIT"
  ];

  static Move? simulateNextMove(String currentPlayerId) {
    if (isGameOver()) return null;

    // If this is the first move, use one of our predefined first moves
    if (_isBoardEmpty()) {
      final firstMove = generateSampleMoves().first;
      return Move(
        word: firstMove.word,
        score: firstMove.score,
        playerId: currentPlayerId,
        timestamp: DateTime.now(),
        tiles: firstMove.tiles,
      );
    }

    // Try to find a valid move using available letters
    for (String word in _validWords) {
      if (_canMakeWord(word)) {
        // Try horizontal placement
        for (int row = 0; row < 15; row++) {
          for (int col = 0; col < 15; col++) {
            if (_isValidWordPlacement(word, row, col, true, false)) {
              final tiles = _createTilesForWord(word, row, col, true);
              final score = calculateWordScore(tiles, false);

              _removeLettersFromBag(word);
              _consecutivePasses = 0;

              return Move(
                word: word,
                score: score,
                playerId: currentPlayerId,
                timestamp: DateTime.now(),
                tiles: tiles,
              );
            }
          }
        }

        // Try vertical placement
        for (int col = 0; col < 15; col++) {
          for (int row = 0; row < 15; row++) {
            if (_isValidWordPlacement(word, row, col, false, false)) {
              final tiles = _createTilesForWord(word, row, col, false);
              final score = calculateWordScore(tiles, false);

              _removeLettersFromBag(word);
              _consecutivePasses = 0;

              return Move(
                word: word,
                score: score,
                playerId: currentPlayerId,
                timestamp: DateTime.now(),
                tiles: tiles,
              );
            }
          }
        }
      }
    }

    // If no valid move found, increment passes
    _consecutivePasses++;
    return null;
  }

  static bool _canMakeWord(String word) {
    Map<String, int> availableLetters = Map.from(_remainingLetters);

    for (String letter in word.split('')) {
      if (!availableLetters.containsKey(letter) ||
          availableLetters[letter]! <= 0) {
        return false;
      }
      availableLetters[letter] = availableLetters[letter]! - 1;
    }

    return true;
  }

  static bool _isBoardEmpty() {
    for (var row in _boardState) {
      for (var cell in row) {
        if (cell != null) return false;
      }
    }
    return true;
  }

  static List<PlacedTile> _createTilesForWord(
      String word, int startRow, int startCol, bool isHorizontal) {
    List<PlacedTile> tiles = [];

    for (int i = 0; i < word.length; i++) {
      final letter = word[i];
      final row = isHorizontal ? startRow : startRow + i;
      final col = isHorizontal ? startCol + i : startCol;

      // Only create tiles for new letters (not existing ones on board)
      if (_boardState[row][col] == null) {
        tiles.add(PlacedTile(
          letter: letter,
          row: row,
          col: col,
          points: letterPoints[letter] ?? 0,
        ));
      }
    }

    return tiles;
  }

  static SquareType getBoardSquareType(int row, int col) {
    // Center square - acts as Double Word Score
    if (row == 7 && col == 7) {
      return SquareType.doubleWord; // Changed from center to doubleWord
    }

    // Triple Word Score (Red)
    if ((row == 0 || row == 14) &&
            (col == 0 || col == 7 || col == 14) || // Corners and middle edges
        (row == 7 && (col == 0 || col == 14))) {
      // Middle row edges
      return SquareType.tripleWord;
    }

    // Double Word Score (Pink)
    if (row == col || row + col == 14) {
      // Diagonals
      if (row >= 1 && row <= 5 || row >= 9 && row <= 13) {
        // Excluding center and edges
        return SquareType.doubleWord;
      }
    }

    // Triple Letter Score (Dark Blue)
    if ((row == 1 || row == 13) && (col == 5 || col == 9) || // Near top/bottom
        (row == 5 || row == 9) &&
            (col == 1 || col == 5 || col == 9 || col == 13)) {
      // Middle area
      return SquareType.tripleLetter;
    }

    // Double Letter Score (Light Blue)
    if ((row == 3 || row == 11) &&
            (col == 0 || col == 7 || col == 14) || // Top/bottom edges
        (row == 6 || row == 8) &&
            (col == 2 || col == 6 || col == 8 || col == 12) || // Middle area
        (row == 0 || row == 7 || row == 14) &&
            (col == 3 || col == 11) || // Left/right edges
        (row == 2 || row == 12) && (col == 6 || col == 8)) {
      // Additional DL squares
      return SquareType.doubleLetter;
    }

    // Normal square
    return SquareType.normal;
  }

// Update calculateWordScore to explicitly check for center square in first move
  static int calculateWordScore(List<PlacedTile> tiles, bool isFirstMove) {
    int wordMultiplier = 1;
    int wordScore = 0;
    bool usedCenterSquare = false;

    for (var tile in tiles) {
      int letterScore = letterPoints[tile.letter] ?? 0;

      // Check if this tile uses the center square
      if (tile.row == 7 && tile.col == 7) {
        usedCenterSquare = true;
      }

      // Apply letter multipliers based on board position
      switch (getBoardSquareType(tile.row, tile.col)) {
        case SquareType.doubleLetter:
          letterScore *= 2;
          break;
        case SquareType.tripleLetter:
          letterScore *= 3;
          break;
        case SquareType.doubleWord:
          wordMultiplier *= 2;
          break;
        case SquareType.tripleWord:
          wordMultiplier *= 3;
          break;
        default:
          break;
      }

      wordScore += letterScore;
    }

    // Apply word multiplier
    wordScore *= wordMultiplier;

    // First move must cross center square and gets double word score
    if (isFirstMove && usedCenterSquare) {
      wordScore *=
          2; // Ensure center square doubles the word score for first move
    }

    // Add Scrabble bonus (50 points) if all 7 letters are used
    if (tiles.length == 7) {
      wordScore += 50;
    }

    return wordScore;
  }

// Update the first move generation to ensure it uses the center square
  static final List<(String, List<PlacedTile>)> _validFirstMoves = [
    (
      "ÉTOILE",
      [
        PlacedTile(letter: "É", row: 7, col: 5, points: 1),
        PlacedTile(letter: "T", row: 7, col: 6, points: 1),
        PlacedTile(
            letter: "O", row: 7, col: 7, points: 1), // Center square - DW
        PlacedTile(letter: "I", row: 7, col: 8, points: 1),
        PlacedTile(letter: "L", row: 7, col: 9, points: 1),
        PlacedTile(letter: "E", row: 7, col: 10, points: 1),
      ]
    ),
    // Add more valid French first words that cross center
  ];
}
```\n
\n### src/themes/app_themes.dart\n
```dart
import 'package:flutter/material.dart';

// Original
class AppTheme123445 {
  static const primaryColor = Color(0xFF1E4B5F);
  static const secondaryColor = Color(0xFF3C7A89);
  static const accentColor = Color(0xFFEBA63F);
  static const backgroundColor = Color(0xFFF5F5F5);
  
  static ThemeData get theme => ThemeData(
    primaryColor: primaryColor,
    scaffoldBackgroundColor: backgroundColor,
    appBarTheme: const AppBarTheme(
      backgroundColor: primaryColor,
      elevation: 0,
      centerTitle: false,
      iconTheme: IconThemeData(color: Colors.white),
      titleTextStyle: TextStyle(
        color: Colors.white,
        fontSize: 24,
        fontWeight: FontWeight.bold,
      ),
    ),
    bottomNavigationBarTheme: const BottomNavigationBarThemeData(
      backgroundColor: primaryColor,
      selectedItemColor: accentColor,
      unselectedItemColor: Colors.white70,
    ),
  );
}

// Modern Dark Theme
class AppTheme {
  static const primaryColor = Color(0xFF1A1A2E);
  static const secondaryColor = Color(0xFF16213E);
  static const accentColor = Color(0xFF00FF95);
  static const backgroundColor = Color(0xFF0F0F1A);
  
  static ThemeData get theme => ThemeData(
    primaryColor: primaryColor,
    scaffoldBackgroundColor: backgroundColor,
    appBarTheme: const AppBarTheme(
      backgroundColor: primaryColor,
      elevation: 0,
      centerTitle: false,
      iconTheme: IconThemeData(color: accentColor),
      titleTextStyle: TextStyle(
        color: Colors.white,
        fontSize: 24,
        fontWeight: FontWeight.bold,
      ),
    ),
    bottomNavigationBarTheme: const BottomNavigationBarThemeData(
      backgroundColor: primaryColor,
      selectedItemColor: accentColor,
      unselectedItemColor: Colors.white54,
    ),
  );
}

// Minimal Light theme 
class AppTheme12345 {
  static const primaryColor = Color(0xFFF8F9FA);
  static const secondaryColor = Color(0xFFE9ECEF);
  static const accentColor = Color(0xFF6C63FF);
  static const backgroundColor = Colors.white;
  
  static ThemeData get theme => ThemeData(
    primaryColor: primaryColor,
    scaffoldBackgroundColor: backgroundColor,
    appBarTheme: const AppBarTheme(
      backgroundColor: primaryColor,
      elevation: 0,
      centerTitle: false,
      iconTheme: IconThemeData(color: accentColor),
      titleTextStyle: TextStyle(
        color: Color(0xFF2D3436),
        fontSize: 24,
        fontWeight: FontWeight.bold,
      ),
    ),
    bottomNavigationBarTheme: const BottomNavigationBarThemeData(
      backgroundColor: primaryColor,
      selectedItemColor: accentColor,
      unselectedItemColor: Color(0xFF95A5A6),
    ),
  );
}

// Natue-inspired Theme
class AppTheme1234 {
  static const primaryColor = Color(0xFF2D5A27);
  static const secondaryColor = Color(0xFF4A8B3C);
  static const accentColor = Color(0xFFFFC857);
  static const backgroundColor = Color(0xFFF7F7F2);
  
  static ThemeData get theme => ThemeData(
    primaryColor: primaryColor,
    scaffoldBackgroundColor: backgroundColor,
    appBarTheme: const AppBarTheme(
      backgroundColor: primaryColor,
      elevation: 0,
      centerTitle: false,
      iconTheme: IconThemeData(color: Colors.white),
      titleTextStyle: TextStyle(
        color: Colors.white,
        fontSize: 24,
        fontWeight: FontWeight.bold,
      ),
    ),
    bottomNavigationBarTheme: const BottomNavigationBarThemeData(
      backgroundColor: primaryColor,
      selectedItemColor: accentColor,
      unselectedItemColor: Colors.white70,
    ),
  );
}
```\n
\n### src/widgets/player_history_sheet.dart\n
```dart
import 'package:flutter/material.dart';
import 'package:oloodi_scrabble_end_user_app/src/models/player.dart';
import 'package:intl/intl.dart';
import 'package:oloodi_scrabble_end_user_app/src/providers/game_state_provider.dart';
import 'package:provider/provider.dart';

class PlayerHistorySheet extends StatelessWidget {
  final Player player;

  const PlayerHistorySheet({
    super.key,
    required this.player,
  });

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.all(16),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        mainAxisSize: MainAxisSize.min,
        children: [
          Row(
            children: [
              Container(
                width: 24,
                height: 24,
                decoration: BoxDecoration(
                  color: player.color,
                  shape: BoxShape.circle,
                ),
              ),
              const SizedBox(width: 8),
              Text(
                '${player.displayName}\'s Moves',
                style: Theme.of(context).textTheme.titleLarge,
              ),
            ],
          ),
          const SizedBox(height: 16),
          Expanded(
            child: Consumer<GameStateProvider>(
              builder: (context, gameState, child) {
                final moves = gameState.getMovesByPlayer(player.id);
                return ListView.builder(
                  itemCount: moves.length,
                  itemBuilder: (context, index) {
                    final move = moves[index];
                    return Card(
                      child: ListTile(
                        leading: CircleAvatar(
                          backgroundColor: player.color,
                          child: Text(
                            move.word[0],
                            style: const TextStyle(color: Colors.white),
                          ),
                        ),
                        title: Text(move.word),
                        subtitle: Text(
                          'Score: ${move.score} points',
                        ),
                        trailing: Text(
                          DateFormat.jm().format(move.timestamp),
                        ),
                      ),
                    );
                  },
                );
              },
            ),
          ),
        ],
      ),
    );
  }
}```\n
\n### src/widgets/move_history_panel.dart\n
```dart
import 'package:flutter/material.dart';
import 'package:oloodi_scrabble_end_user_app/src/providers/game_state_provider.dart';
import 'package:provider/provider.dart';

class MoveHistoryPanel extends StatelessWidget {
  const MoveHistoryPanel({super.key});

  @override
  Widget build(BuildContext context) {
    return Consumer<GameStateProvider>(
      builder: (context, gameState, child) {
        final distribution = gameState.letterDistribution;

        return Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Container(
              padding: const EdgeInsets.all(16),
              decoration: BoxDecoration(
                color: Theme.of(context).colorScheme.surface,
                border: Border(
                  bottom: BorderSide(
                    color: Theme.of(context).dividerColor,
                  ),
                ),
              ),
              child: Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: [
                  const Text(
                    'Move History',
                    style: TextStyle(
                      fontSize: 20,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                  Tooltip(
                    message: distribution.entries
                        .where((e) => e.value > 0)
                        .map((e) => '${e.key}: ${e.value}')
                        .join('\n'),
                    child: Text(
                      'Remaining: ${gameState.remainingLetters}',
                      style: const TextStyle(
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                  ),
                ],
              ),
            ),
            Expanded(
              child: ListView.builder(
                itemCount: gameState.moves.length,
                itemBuilder: (context, index) {
                  final move = gameState.moves[index];
                  final player = gameState.players.firstWhere(
                    (p) => p.id == move.playerId,
                  );

                  return ListTile(
                    leading: CircleAvatar(
                      backgroundColor: player.color,
                      child: Text(
                        move.word[0],
                        style: const TextStyle(color: Colors.white),
                      ),
                    ),
                    title: Text(move.word),
                    subtitle:
                        Text('${player.displayName} - ${move.score} points'),
                    trailing: Text(
                      '${index + 1}',
                      style: Theme.of(context).textTheme.bodySmall,
                    ),
                  );
                },
              ),
            ),
          ],
        );
      },
    );
  }
}
```\n
\n### src/widgets/camera_widget.dart\n
```dart
import 'package:flutter/material.dart';
import 'package:camera/camera.dart';
import 'package:oloodi_scrabble_end_user_app/src/providers/game_state_provider.dart';
import 'package:oloodi_scrabble_end_user_app/src/service/camera_service.dart';
import 'package:oloodi_scrabble_end_user_app/src/service/gemini_service.dart';
import 'package:provider/provider.dart';

class CameraWidget extends StatefulWidget {
  const CameraWidget({super.key});

  @override
  State<CameraWidget> createState() => _CameraWidgetState();
}

class _CameraWidgetState extends State<CameraWidget> {
  late CameraService _cameraService;
  bool _isInitializing = true;

  @override
  void initState() {
    super.initState();
    _cameraService = CameraService();
    _initializeCamera();
  }

  Future<void> _initializeCamera() async {
    try {
      await _cameraService.initialize();
    } catch (e) {
      // Handle initialization error
    } finally {
      if (mounted) {
        setState(() => _isInitializing = false);
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    if (_isInitializing) {
      return const Center(child: CircularProgressIndicator());
    }

    return Container(
      height: 300,
      child: Stack(
        children: [
          if (_cameraService.isInitialized)
            CameraPreview(_cameraService.controller!),
          Positioned(
            bottom: 20,
            left: 0,
            right: 0,
            child: Row(
              mainAxisAlignment: MainAxisAlignment.spaceEvenly,
              children: [
                IconButton(
                  icon: const Icon(Icons.camera_alt, color: Colors.white),
                  onPressed: _captureAndAnalyze,
                ),
                IconButton(
                  icon: const Icon(Icons.flip_camera_android,
                      color: Colors.white),
                  onPressed: () {
                    // Implement camera flip
                  },
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }

  Future<void> _captureAndAnalyze() async {
    try {
      final imagePath = await _cameraService.captureImage();
      final gameState = context.read<GameStateProvider>();

      // Show loading indicator
      showDialog(
        context: context,
        barrierDismissible: false,
        builder: (context) => const Center(child: CircularProgressIndicator()),
      );

      // Analyze image using Gemini
      final geminiService = GeminiService();
      final analysis = await geminiService.analyzeBoardImage(imagePath);

      // Update game state with new board state
      if (analysis['status'] == 'success') {
        // Implementation needed: Update game state with analysis results
        // gameState.updateBoardFromAnalysis(analysis['data']);
      }

      // Close loading indicator
      Navigator.pop(context);
    } catch (e) {
      // Handle capture error
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Error capturing image: ${e.toString()}')),
      );
    }
  }

  @override
  void dispose() {
    _cameraService.dispose();
    super.dispose();
  }
}
```\n
\n### src/widgets/player_score_card.dart\n
```dart
import 'package:flutter/material.dart';
import 'package:oloodi_scrabble_end_user_app/src/models/player.dart';
import 'package:oloodi_scrabble_end_user_app/src/themes/app_themes.dart';
class PlayerScoreCard extends StatelessWidget {
  final Player player;
  final int score;
  final bool isCurrentPlayer;

  const PlayerScoreCard({
    super.key,
    required this.player,
    required this.score,
    required this.isCurrentPlayer,
  });

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.all(12),
      decoration: BoxDecoration(
        color: Colors.white.withOpacity(0.1),
        borderRadius: BorderRadius.circular(8),
        border: Border.all(
          color: isCurrentPlayer ? AppTheme.accentColor : Colors.transparent,
          width: 2,
        ),
      ),
      child: Row(
        children: [
          // Player image
          Container(
            width: 48,
            height: 48,
            decoration: BoxDecoration(
              shape: BoxShape.circle,
              border: Border.all(
                color: AppTheme.accentColor,
                width: 2,
              ),
            ),
            child: ClipOval(
              child: Image.asset(
                player.imagePath,
                fit: BoxFit.cover,
                errorBuilder: (context, error, stackTrace) {
                  return Container(
                    color: Colors.white24,
                    child: const Icon(
                      Icons.person,
                      color: Colors.white,
                      size: 24,
                    ),
                  );
                },
              ),
            ),
          ),
          const SizedBox(width: 12),
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  player.displayName,
                  style: const TextStyle(
                    color: Colors.white,
                    fontWeight: FontWeight.bold,
                    fontSize: 14,
                  ),
                ),
                const SizedBox(height: 4),
                Text(
                  'Score: $score',
                  style: TextStyle(
                    color: AppTheme.accentColor,
                    fontSize: 16,
                    fontWeight: FontWeight.bold,
                  ),
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }
}```\n
\n### src/widgets/board_widget.dart\n
```dart
// lib/widgets/board_widget.dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../providers/game_state_provider.dart';
import '../models/board_square.dart';
import '../models/tile.dart';
// lib/widgets/board_widget.dart
class BoardWidget extends StatefulWidget {
  const BoardWidget({super.key});

  @override
  State<BoardWidget> createState() => _BoardWidgetState();
}

class _BoardWidgetState extends State<BoardWidget> {
  double _scale = 1.0;
  Offset _offset = Offset.zero;
  late TransformationController _transformationController;

  @override
  void initState() {
    super.initState();
    _transformationController = TransformationController();
  }

  @override
  void dispose() {
    _transformationController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      onScaleStart: (details) {
        _scale = _transformationController.value.getMaxScaleOnAxis();
        _offset = details.focalPoint;
      },
      onScaleUpdate: (details) {
        final newScale = (_scale * details.scale).clamp(0.8, 2.0);
        final focalPoint = details.focalPoint;
        _transformationController.value = Matrix4.identity()
          ..translate(focalPoint.dx - _offset.dx, focalPoint.dy - _offset.dy)
          ..scale(newScale);
      },
      child: InteractiveViewer(
        transformationController: _transformationController,
        minScale: 0.8,
        maxScale: 2.0,
        child: Consumer<GameStateProvider>(
          builder: (context, gameState, child) {
            return AspectRatio(
              aspectRatio: 1,
              child: GridView.builder(
                physics: const NeverScrollableScrollPhysics(),
                gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
                  crossAxisCount: 15,
                  childAspectRatio: 1,
                ),
                itemCount: 225,
                itemBuilder: (context, index) {
                  final row = index ~/ 15;
                  final col = index % 15;
                  final square = gameState.board[row][col];
                  
                  return _buildSquare(square, gameState);
                },
              ),
            );
          },
        ),
      ),
    );
  }

  Widget _buildSquare(BoardSquare square, GameStateProvider gameState) {
    return Container(
      decoration: BoxDecoration(
        border: Border.all(color: Colors.black12),
        color: _getSquareColor(square.type),
      ),
      child: square.tile != null
          ? _buildTile(square.tile!, gameState)
          : _buildSquareContent(square.type),
    );
  }
Widget _buildTile(Tile tile, GameStateProvider gameState) {
    final player = gameState.players.firstWhere(
      (p) => p.id == tile.playerId,
      orElse: () => gameState.players[0],
    );

    return AnimatedScale(
      scale: tile.isNew ? 0.0 : 1.0,
      duration: const Duration(milliseconds: 500),
      curve: Curves.elasticOut,
      child: AnimatedRotation(
        turns: tile.isNew ? -0.5 : 0,
        duration: const Duration(milliseconds: 500),
        curve: Curves.elasticOut,
        child: Container(
          margin: const EdgeInsets.all(1),
          decoration: BoxDecoration(
            color: const Color(0xFFF7D698),
            borderRadius: BorderRadius.circular(4),
            boxShadow: [
              BoxShadow(
                color: Colors.black.withOpacity(0.2),
                blurRadius: 2,
                offset: const Offset(1, 1),
              ),
            ],
            border: Border.all(
              color: player.color,
              width: 2,
            ),
          ),
          child: Stack(
            fit: StackFit.expand,
            children: [
              // Letter - left aligned
              Positioned(
                left: 4,
                top: 0,
                bottom: 0,
                child: Center(
                  child: Text(
                    tile.letter,
                    style: const TextStyle(
                      fontSize: 13,
                      fontWeight: FontWeight.bold,
                      color: Colors.black87,
                    ),
                  ),
                ),
              ),
              // Points - right aligned
              Positioned(
                right: 2,
                bottom: 1,
                child: Text(
                  '${tile.points}',
                  style: const TextStyle(
                    fontSize: 7,
                    fontWeight: FontWeight.bold,
                    color: Colors.black54,
                  ),
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildSquareContent(SquareType type) {
    String label = '';
    switch (type) {
      case SquareType.tripleWord:
        label = 'TW';
        break;
      case SquareType.doubleWord:
        label = 'DW';
        break;
      case SquareType.tripleLetter:
        label = 'TL';
        break;
      case SquareType.doubleLetter:
        label = 'DL';
        break;
      case SquareType.center:
        label = '★';
        break;
      default:
        return const SizedBox();
    }

    return Center(
      child: Text(
        label,
        style: TextStyle(
          fontSize: 10,
          fontWeight: FontWeight.bold,
          color: _getSquareColor(type).computeLuminance() > 0.5
              ? Colors.black54
              : Colors.white70,
        ),
      ),
    );
  }

  Color _getSquareColor(SquareType type) {
    switch (type) {
      case SquareType.tripleWord:
        return Colors.red[100]!;
      case SquareType.doubleWord:
        return Colors.pink[50]!;
      case SquareType.tripleLetter:
        return Colors.blue[100]!;
      case SquareType.doubleLetter:
        return Colors.lightBlue[50]!;
      case SquareType.center:
        return Colors.pink[50]!;
      default:
        return Colors.white;
    }
  }
}```\n
\n## pubspec.yaml\n
```yaml
name: oloodi_scrabble_end_user_app
description: A dynamic Scrabble AI app that enhances the traditional Scrabble game experience using Flutter and Gemini SDK.

# The following line prevents the package from being accidentally published to
# pub.dev using `flutter pub publish`. This is preferred for private packages.
publish_to: 'none'

# Version number
version: 1.0.0+1

environment:
  sdk: '>=3.0.0 <4.0.0'

# Dependencies specify other packages that your package needs in order to work.
dependencies:
  flutter:
    sdk: flutter
  
  # UI and Core
  cupertino_icons: ^1.0.2
  google_fonts: ^6.1.0
  flutter_svg: ^2.0.9
  
  # State Management
  provider: ^6.1.1
  
  # Camera and Image Processing
  camera: ^0.10.5+9
  image_picker: ^1.0.7
  path_provider: ^2.1.2
  path: ^1.8.3
  
  # Animations
  animations: ^2.0.11
  flutter_animate: ^4.5.0
  
  # Gemini SDK
  google_generative_ai: ^0.2.0
  
  # Storage and Database
  shared_preferences: ^2.2.2
  sqflite: ^2.3.2
  
  # Utils
  intl: ^0.20.2
  logger: ^2.0.2+1
  uuid: ^4.3.3
  
  # Network and API
  http: ^1.2.0
  connectivity_plus: ^5.0.2
  firebase_core: ^3.10.1
  cloud_firestore: ^5.6.2
  firebase_auth: ^5.4.1
  json_annotation: ^4.9.0

dev_dependencies:
  flutter_test:
    sdk: flutter
    
  # Development Tools
  flutter_lints: ^3.0.1
  build_runner: ^2.4.13
  mockito: ^5.4.4
  flutter_launcher_icons: ^0.13.1
  flutter_native_splash: ^2.3.10
  json_serializable: ^6.9.0

# Flutter configuration
flutter:
  uses-material-design: true
  
  # Assets
  assets:
    - assets/images/
    
  # Fonts (uncomment and add custom fonts if needed)
  # fonts:
  #   - family: CustomFont
  #     fonts:
  #       - asset: fonts/CustomFont-Regular.ttf
  #       - asset: fonts/CustomFont-Bold.ttf
  #         weight: 700

# Flutter Launcher Icons configuration (customize as needed)
flutter_launcher_icons:
  android: "launcher_icon"
  ios: true
  image_path: "assets/icons/app_icon.png"
  min_sdk_android: 21
  adaptive_icon_background: "#FFFFFF"
  adaptive_icon_foreground: "assets/icons/app_icon_foreground.png"

# Flutter Native Splash configuration (customize as needed)
flutter_native_splash:
  color: "#FFFFFF"
  image: assets/images/splash.png
  android_12:
    image: assets/images/splash.png
    color: "#FFFFFF"
  ios: true
```
